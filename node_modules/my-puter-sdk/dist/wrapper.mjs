var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/puter.dev.js
(() => {
  var e = { 294: (e2, t2, s2) => {
    const { AdvancedBase: n } = s2(952), { Service: i } = s2(866), { ServiceManager: r } = s2(875), o = s2(868);
    e2.exports = { AdvancedBase: n, system: { ServiceManager: r }, libs: { promise: s2(717), context: s2(475), listener: s2(498), log: s2(346), string: s2(519), time: s2(259), smol: s2(9), event: s2(140) }, features: { EmitterFeature: s2(891) }, concepts: { Service: i }, traits: o };
  }, 952: (e2, t2, s2) => {
    const { FeatureBase: n } = s2(533);
    class i extends n {
      static FEATURES = [s2(912), s2(314), s2(178), s2(659), s2(73)];
    }
    e2.exports = { AdvancedBase: i };
  }, 777: (e2) => {
    class t2 {
      _get_inheritance_chain() {
        const e3 = [];
        let s2 = this.constructor;
        for (; s2 && s2 !== t2; )
          e3.push(s2), s2 = s2.__proto__;
        return e3.reverse();
      }
      _get_merged_static_array(e3) {
        const t3 = this._get_inheritance_chain(), s2 = [];
        let n = null;
        for (const i of t3)
          i[e3] && i[e3] !== n && (n = i[e3], s2.push(...i[e3]));
        return s2;
      }
      _get_merged_static_object(e3) {
        const t3 = this._get_inheritance_chain(), s2 = {};
        for (const n of t3)
          n[e3] && Object.assign(s2, n[e3]);
        return s2;
      }
    }
    e2.exports = { BasicBase: t2 };
  }, 533: (e2, t2, s2) => {
    const { BasicBase: n } = s2(777);
    e2.exports = { FeatureBase: class extends n {
      constructor(e3, ...t3) {
        super(e3, ...t3), this._ = { features: this._get_merged_static_array("FEATURES") };
        for (const t4 of this._.features)
          t4.install_in_instance(this, { parameters: e3 || {} });
      }
    } };
  }, 866: (e2, t2, s2) => {
    const { AdvancedBase: n } = s2(952), i = s2(696), r = async () => {
    }, o = Symbol("TService");
    e2.exports = { TService: o, Service: class extends n {
      static FEATURES = [i];
      async __on(e3, t3) {
        const s3 = this.__get_event_handler(e3);
        return await s3(e3, ...t3);
      }
      __get_event_handler(e3) {
        var _a, _b, _c, _d;
        return ((_b = (_a = this[`__on_${e3}`]) == null ? void 0 : _a.bind) == null ? void 0 : _b.call(_a, this)) || ((_d = (_c = this.constructor[`__on_${e3}`]) == null ? void 0 : _c.bind) == null ? void 0 : _d.call(_c, this.constructor)) || r;
      }
      static create({ parameters: e3, context: t3 }) {
        const s3 = new this();
        return s3._.context = t3, s3.as(o).construct(e3), s3;
      }
      static IMPLEMENTS = { [o]: { init(...e3) {
        if (this._.init_hooks)
          for (const e4 of this._.init_hooks)
            e4.call(this);
        if (this._init)
          return this._init(...e3);
      }, construct(e3) {
        this.$parameters = {};
        for (const t3 in e3)
          this.$parameters[t3] = e3[t3];
        if (this._construct)
          return this._construct(e3);
      }, get_depends() {
        var _a, _b, _c;
        return [...(_a = this.constructor.DEPENDS) != null ? _a : [], ...(_c = (_b = this.get_depends) == null ? void 0 : _b.call(this)) != null ? _c : []];
      } } };
    } };
  }, 891: (e2) => {
    e2.exports = ({ decorators: e3 } = {}) => ({ install_in_instance(t2, { parameters: s2 }) {
      const n = t2._.emitterFeature = {};
      n.listeners_ = {}, n.global_listeners_ = [], n.callbackDecorators = e3 || [], t2.emit = async (e4, t3, s3) => {
        s3 = s3 != null ? s3 : {};
        const i = e4.split("."), r = [];
        for (let i2 = 0; i2 < n.global_listeners_.length; i2++) {
          let o = n.global_listeners_[i2];
          for (const e5 of n.callbackDecorators)
            o = e5(o);
          r.push(o(e4, t3, { ...s3, key: e4 }));
        }
        for (let o = 0; o < i.length; o++) {
          const a = o === i.length - 1 ? i.join(".") : i.slice(0, o + 1).join(".") + ".*", c = n.listeners_[a];
          if (c)
            for (let i2 = 0; i2 < c.length; i2++) {
              let o2 = c[i2];
              for (const e5 of n.callbackDecorators)
                o2 = e5(o2);
              r.push(o2(t3, { ...s3, key: e4 }));
            }
        }
        return await Promise.all(r);
      }, t2.on = (e4, t3) => {
        const s3 = n.listeners_[e4] || (n.listeners_[e4] = []);
        return s3.push(t3), { detach: () => {
          const e5 = s3.indexOf(t3);
          -1 !== e5 && s3.splice(e5, 1);
        } };
      }, t2.on_all = (e4) => {
        n.global_listeners_.push(e4);
      };
    } });
  }, 659: (e2) => {
    e2.exports = { readme: "\n        Normalized Asynchronous Request Invocation (NARI) Methods Feature\n\n        This feature allows a class to define \"Nari methods\", which are methods\n        that support both async/await and callback-style invocation, have\n        positional arguments, and an options argument.\n\n        \"the expected interface for methods in puter.js\"\n\n        The underlying method will receive parameters as an object, with the\n        positional arguments as keys in the object. The options argument will\n        be merged into the parameters object unless the method spec specifies\n        `separate_options: true`.\n\n        Example:\n\n        ```\n        class MyClass extends AdvancedBase {\n            static NARI_METHODS = {\n                myMethod: {\n                    positional: ['param1', 'param2'],\n                    fn: ({ param1, param2 }) => {\n                        return param1 + param2;\n                    }\n                }\n            }\n        }\n\n        const instance = new MyClass();\n        const result = instance.myMethod(1, 2); // returns 3\n        ```\n\n        The method can also be called with options and callbacks:\n\n        ```\n        instance.myMethod(1, 2, { option1: 'value' }, (result) => {\n            console.log('success', result);\n        }, (error) => {\n            console.error('error', error);\n        });\n        ```\n    ", install_in_instance: (e3) => {
      const t2 = e3._get_merged_static_object("NARI_METHODS");
      e3._.nariMethods = {};
      for (const s2 in t2) {
        const n = t2[s2], i = n.fn.bind(e3);
        e3._.nariMethods[s2] = i, e3[s2] = async (...e4) => {
          const t3 = n.firstarg_options && "object" == typeof e4[0] ? 0 : n.positional.length, s3 = e4.slice(0, t3), r = e4.slice(t3), o = {}, a = {}, c = {};
          for (const [e5, t4] of s3.entries())
            o[n.positional[e5]] = t4;
          let l;
          "object" == typeof r[0] && (Object.assign(a, r[0]), r.shift()), "function" == typeof r[0] ? (c.success = r[0], r.shift()) : a.success && (c.success = a.success), "function" == typeof r[0] ? (c.error = r[0], r.shift()) : a.error && (c.error = a.error), n.separate_options ? o.options = a : Object.assign(o, a);
          try {
            l = await i(o);
          } catch (e5) {
            if (!c.error)
              throw e5;
            c.error(e5);
          }
          return c.success && c.success(l), l;
        };
      }
    } };
  }, 912: (e2, t2, s2) => {
    e2.exports = { install_in_instance: (e3, { parameters: t3 }) => {
      const n = e3._get_merged_static_object("MODULES");
      if (t3.modules)
        for (const e4 in t3.modules)
          n[e4] = t3.modules[e4];
      e3.modules = n, e3.require = (e4) => n[e4] ? n[e4] : s2(274)(e4);
    } };
  }, 314: (e2) => {
    e2.exports = { name: "Properties", depends: ["Listeners"], install_in_instance: (e3, { parameters: t2 }) => {
      const s2 = e3._get_merged_static_object("PROPERTIES");
      e3.onchange = (t3, s3) => {
        e3._.properties[t3].listeners.push(s3);
      }, e3._.properties = {};
      for (const n in s2) {
        const i = { definition: s2[n], listeners: [], value: void 0 };
        e3._.properties[n] = i;
        let r = null;
        if ("object" == typeof s2[n] ? (r = s2[n], r.factory && (r.value = r.factory({ parameters: t2 }))) : "function" == typeof s2[n] && (r = {}, r.value = s2[n]()), null === r)
          throw new Error("this will never happen");
        if (Object.defineProperty(e3, n, { get: () => i.value, set: (t3) => {
          for (const s4 of e3._.properties[n].listeners)
            s4(t3, { old_value: e3[n] });
          const s3 = e3[n], o = t3;
          r.adapt && (t3 = r.adapt(t3)), i.value = t3, r.post_set && r.post_set.call(e3, t3, { intermediate_value: o, old_value: s3 });
        } }), i.value = r.value, s2[n].construct) {
          const i2 = "string" == typeof s2[n].construct ? s2[n].construct : n;
          e3[n] = t2[i2];
        }
      }
    } };
  }, 696: (e2, t2, s2) => {
    const { TTopics: n } = s2(868);
    e2.exports = { install_in_instance: (e3, { parameters: t3 }) => {
      var _a;
      const s3 = e3._get_merged_static_array("HOOKS");
      e3._.init_hooks = (_a = e3._.init_hooks) != null ? _a : [];
      for (const t4 of s3)
        e3._.init_hooks.push(() => {
          e3._.context.services.info(t4.service).instance.as(n).sub(t4.event, t4.do.bind(e3));
        });
    } };
  }, 73: (e2, t2, s2) => {
    const { RemoveFromArrayDetachable: n } = s2(498), { TTopics: i } = s2(868), { install_in_instance: r } = s2(912);
    e2.exports = { install_in_instance: (e3, { parameters: t3 }) => {
      const s3 = e3._get_merged_static_array("TOPICS");
      e3._.topics = {};
      for (const t4 of s3)
        e3._.topics[t4] = { listeners_: [] };
      e3.mixin(i, { pub: (t4, s4) => {
        if (t4.includes("!"))
          throw new Error('"!" in event name reserved for future use');
        const n2 = e3._.topics[t4];
        if (n2)
          for (const e4 of n2.listeners_)
            e4();
        else
          console.warn("missing topic: " + n2);
      }, sub: (t4, s4) => {
        const i2 = e3._.topics[t4];
        if (i2)
          return i2.listeners_.push(s4), new n(i2.listeners_, s4);
        console.warn("missing topic: " + i2);
      } });
    } };
  }, 178: (e2) => {
    e2.exports = { install_in_instance_: (e3, { parameters: t2 }) => {
      const s2 = e3._get_merged_static_object("IMPLEMENTS");
      e3._.impls = {};
      for (const t3 in s2) {
        const n = s2[t3], i = {};
        for (const t4 in n) {
          const s3 = n[t4];
          i[t4] = s3.bind(e3);
        }
        e3._.impls[t3] = i;
      }
      e3.as = (t3) => e3._.impls[t3], e3.list_traits = () => Object.keys(e3._.impls);
    }, install_in_instance: (e3, { parameters: t2 }) => {
      var _a;
      const s2 = e3._get_inheritance_chain();
      e3._.impls = {}, e3.as = (t3) => e3._.impls[t3], e3.list_traits = () => Object.keys(e3._.impls), e3.mixin = (t3, s3) => e3._.impls[t3] = s3;
      for (const t3 of s2) {
        const s3 = t3.IMPLEMENTS;
        if (!s3)
          continue;
        const n = [...Object.getOwnPropertySymbols(s3), ...Object.keys(s3)];
        for (const t4 of n) {
          const n2 = (_a = e3._.impls[t4]) != null ? _a : e3._.impls[t4] = {}, i = s3[t4];
          for (const t5 in i) {
            const s4 = i[t5];
            n2[t5] = s4.bind(e3);
          }
        }
      }
    } };
  }, 274: (e2) => {
    function t2(e3) {
      var t3 = new Error("Cannot find module '" + e3 + "'");
      throw t3.code = "MODULE_NOT_FOUND", t3;
    }
    t2.keys = () => [], t2.resolve = t2, t2.id = 274, e2.exports = t2;
  }, 475: (e2) => {
    class t2 {
      constructor(e3 = {}) {
        const t3 = Object.getOwnPropertyDescriptors(e3);
        for (const e4 in t3)
          Object.defineProperty(this, e4, t3[e4]);
      }
      follow(e3, t3) {
        const s2 = {};
        for (const n of t3)
          Object.defineProperty(s2, n, { get: () => e3[n] });
        return this.sub(s2);
      }
      sub(e3) {
        void 0 === e3 && (e3 = {});
        const s2 = Object.create(this), n = {};
        for (const i2 in s2)
          if (s2[i2] instanceof t2) {
            const t3 = e3.hasOwnProperty(i2) ? e3[i2] : void 0;
            s2[i2] = s2[i2].sub(t3), n[i2] = true;
          }
        const i = Object.getOwnPropertyDescriptors(e3);
        for (const e4 in i)
          n[e4] || Object.defineProperty(s2, e4, i[e4]);
        return s2;
      }
    }
    e2.exports = { Context: t2 };
  }, 140: (e2, t2, s2) => {
    const { AdvancedBase: n } = s2(952), i = s2(891);
    class r extends n {
      static FEATURES = [i()];
    }
    e2.exports = { Emitter: r };
  }, 498: (e2, t2, s2) => {
    const { FeatureBase: n } = s2(533), { TDetachable: i } = s2(868);
    class r extends n {
      static FEATURES = [s2(178)];
      constructor() {
        super(), this.delegates = [], this.detached_ = false;
      }
      add(e3) {
        this.detached_ ? e3.detach() : this.delegates.push(e3);
      }
      static IMPLEMENTS = { [i]: { detach() {
        this.detached_ = true;
        for (const e3 of this.delegates)
          e3.detach();
      } } };
    }
    class o extends n {
      static FEATURES = [s2(178)];
      constructor() {
        super(), this.also = () => {
        };
      }
      also(e3) {
        return this.also = e3, this;
      }
      static IMPLEMENTS = { [i]: { detach() {
        this.detach_(), this.also();
      } } };
    }
    e2.exports = { MultiDetachable: r, RemoveFromArrayDetachable: class extends o {
      constructor(e3, t3) {
        super(), this.array = new WeakRef(e3), this.element = t3;
      }
      detach_() {
        const e3 = this.array.deref();
        if (!e3)
          return;
        const t3 = e3.indexOf(this.element);
        -1 !== t3 && e3.splice(t3, 1);
      }
    } };
  }, 346: (e2, t2, s2) => {
    const { AdvancedBase: n } = s2(952), { TLogger: i, AS: r } = s2(868);
    class o extends n {
      static MODULES = { util: { inspect: (e3) => e3 } };
      static PROPERTIES = { console: { construct: true, factory: () => console }, format: () => ({ info: { ansii: "\x1B[32;1m" }, warn: { ansii: "\x1B[33;1m" }, error: { ansii: "\x1B[31;1m", err: true }, debug: { ansii: "\x1B[34;1m" } }) };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        var _a;
        const i2 = (0, this.require)("util"), r2 = this.format[e3];
        let o2 = "";
        o2 += `${r2.ansii}[${e3.toUpperCase()}]\x1B[0m `, o2 += t3, Object.keys(s3).length && (o2 += " ", o2 += Object.entries(s3).map(([e4, t4]) => `
  ${e4}=${i2.inspect(t4)}`).join(" ") + "\n"), ((_a = this.console) != null ? _a : console)[r2.err ? "error" : "log"](o2, ...n2);
      } } };
    }
    class a extends n {
      static PROPERTIES = { fields: { construct: true, factory: () => ({}) }, delegate: { construct: true, value: null, adapt: (e3) => r(e3, i) } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        return this.delegate.log(e3, t3, Object.assign({}, this.fields, s3), n2);
      } } };
    }
    class c extends n {
      static PROPERTIES = { impl: { value: () => new o(), adapt: (e3) => r(e3, i), construct: true }, cat: { construct: true } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        console.log();
      } } };
      fields(e3) {
        const t3 = new a({ fields: e3, delegate: this.impl });
        return new c({ impl: t3 });
      }
      info(e3, ...t3) {
        this.impl.log("info", e3, {}, t3);
      }
      on(e3) {
        this.cat.on(e3);
      }
      off(e3) {
        this.cat.off(e3);
      }
    }
    e2.exports = { ArrayLogger: class extends n {
      static PROPERTIES = { buffer: { factory: () => [] } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        this.buffer.push({ level: e3, message: t3, fields: s3, values: n2 });
      } } };
    }, CategorizedToggleLogger: class extends n {
      static PROPERTIES = { categories: { description: "categories that are enabled", factory: () => ({}) }, delegate: { construct: true, value: null, adapt: (e3) => r(e3, i) } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        const i2 = s3.category;
        if (this.categories[i2])
          return this.delegate.log(e3, t3, s3, n2);
      } } };
      on(e3) {
        this.categories[e3] = true;
      }
      off(e3) {
        delete this.categories[e3];
      }
    }, ToggleLogger: class extends n {
      static PROPERTIES = { enabled: { construct: true, value: true }, delegate: { construct: true, value: null, adapt: (e3) => r(e3, i) } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        if (this.enabled)
          return this.delegate.log(e3, t3, s3, n2);
      } } };
    }, ConsoleLogger: o, PrefixLogger: class extends n {
      static PROPERTIES = { prefix: { construct: true, value: "" }, delegate: { construct: true, value: null, adapt: (e3) => r(e3, i) } };
      static IMPLEMENTS = { [i]: { log(e3, t3, s3, n2) {
        return this.delegate.log(e3, this.prefix + t3, s3, n2);
      } } };
    }, FieldsLogger: a, LoggerFacade: c };
  }, 717: (e2) => {
    class t2 {
      static STATUS_PENDING = Symbol("pending");
      static STATUS_RUNNING = {};
      static STATUS_DONE = Symbol("done");
      constructor() {
        this.status_ = this.constructor.STATUS_PENDING, this.donePromise = new Promise((e3, t3) => {
          this.doneResolve = e3, this.doneReject = t3;
        });
      }
      get status() {
        return this.status_;
      }
      set status(e3) {
        this.status_ = e3, e3 === this.constructor.STATUS_DONE && this.doneResolve();
      }
      resolve(e3) {
        this.status_ = this.constructor.STATUS_DONE, this.doneResolve(e3);
      }
      awaitDone() {
        return this.donePromise;
      }
      then(e3, ...t3) {
        return this.donePromise.then(e3, ...t3);
      }
      reject(e3) {
        this.status_ = this.constructor.STATUS_DONE, this.doneReject(e3);
      }
      onComplete(e3) {
        return this.then(e3);
      }
    }
    class s2 {
      static TYPE_READ = Symbol("read");
      static TYPE_WRITE = Symbol("write");
      constructor() {
        this.queue = [], this.readers_ = 0, this.writer_ = false, this.on_empty_ = () => {
        }, this.mode = this.constructor.TYPE_READ;
      }
      get effective_mode() {
        return this.readers_ > 0 ? this.constructor.TYPE_READ : this.writer_ ? this.constructor.TYPE_WRITE : void 0;
      }
      push_(e3) {
        0 !== this.readers_ || this.writer_ || (this.mode = e3.type), this.queue.push(e3), this.check_queue_();
      }
      check_queue_() {
        var _a;
        if (0 === this.queue.length)
          return void (0 !== this.readers_ || this.writer_ || this.on_empty_());
        const e3 = () => this.queue[0];
        if (0 !== this.readers_ || this.writer_ || (this.mode = e3().type), this.mode === this.constructor.TYPE_READ) {
          for (; ((_a = e3()) == null ? void 0 : _a.type) === this.constructor.TYPE_READ; ) {
            const e4 = this.queue.shift();
            this.readers_++, (async () => {
              await e4.p_unlock, this.readers_--, this.check_queue_();
            })(), e4.p_operation.resolve();
          }
          return;
        }
        if (this.writer_)
          return;
        const t3 = this.queue.shift();
        this.writer_ = true, (async () => {
          await t3.p_unlock, this.writer_ = false, this.check_queue_();
        })(), t3.p_operation.resolve();
      }
      async rlock() {
        const e3 = new t2(), s3 = new t2(), n = { unlock: () => {
          s3.resolve();
        } };
        return this.push_({ type: this.constructor.TYPE_READ, p_operation: e3, p_unlock: s3 }), await e3, n;
      }
      async wlock() {
        const e3 = new t2(), s3 = new t2(), n = { unlock: () => {
          s3.resolve();
        } };
        return this.push_({ type: this.constructor.TYPE_WRITE, p_operation: e3, p_unlock: s3 }), await e3, n;
      }
    }
    e2.exports = { TeePromise: t2, Lock: class {
      constructor() {
        this._locked = false, this._waiting = [];
      }
      async acquire(e3) {
        if (await new Promise((e4) => {
          this._locked ? this._waiting.push({ resolve: e4 }) : (this._locked = true, e4());
        }), e3) {
          let t3;
          try {
            t3 = await e3();
          } finally {
            this.release();
          }
          return t3;
        }
      }
      release() {
        if (this._waiting.length > 0) {
          const { resolve: e3 } = this._waiting.shift();
          e3();
        } else
          this._locked = false;
      }
    }, RWLock: s2, asyncSafeSetInterval: async (e3, t3, s3, n) => {
      s3 = s3 != null ? s3 : [], n = n != null ? n : {};
      const { onBehindSchedule: i } = n, r = (e4) => new Promise((t4) => setTimeout(t4, e4));
      for (; ; ) {
        await r(t3);
        const n2 = Date.now();
        await e3(...s3);
        const o = t3 - (Date.now() - n2);
        if (o < 0) {
          if (i && await i(-o))
            return;
        } else
          await r(o);
      }
    }, raceCase: async (e3) => Promise.race(Object.entries(e3).map(([e4, t3]) => t3.then((t4) => [e4, t4]))) };
  }, 9: (e2) => {
    e2.exports = class {
      static ensure_array(e3) {
        return Array.isArray(e3) ? e3 : [e3];
      }
      static add(...e3) {
        return e3.reduce((e4, t2) => e4 + t2, 0);
      }
      static split(e3, t2, s2 = {}) {
        s2 = s2 || {};
        const { trim: n, discard_empty: i } = s2, r = [];
        s2.trim && r.push((e4) => e4.map((e5) => e5.trim())), s2.discard_empty && r.push((e4) => e4.filter((e5) => e5.length > 0));
        let o = e3.split(t2);
        for (const e4 of r)
          o = e4(o);
        return o;
      }
    };
  }, 519: (e2) => {
    e2.exports = { quot: (e3) => void 0 === e3 ? "[undefined]" : null === e3 ? "[null]" : "function" == typeof e3 ? "[function]" : "object" == typeof e3 ? "[object]" : "number" == typeof e3 ? "(" + e3 + ")" : (e3 = (e3 = "" + e3).replace(/["`]/g, (e4) => '"' === e4 ? "`" : '"'), e3 = (e3 = JSON.stringify("" + e3)).replace(/["`]/g, (e4) => '"' === e4 ? "`" : '"')), osclink: (e3, t2) => (t2 || (t2 = e3), `\x1B]8;;${e3}\x1B\\${t2}\x1B]8;;\x1B\\`), format_as_usd: (e3) => e3 < 0.01 ? e3 < 1e-5 ? "$" + e3.toExponential(2) : "$" + e3.toFixed(5) : "$" + e3.toFixed(2) };
  }, 259: (e2) => {
    class t2 {
      static valueOf() {
        return this.value;
      }
    }
    class s2 extends t2 {
      static value = 1;
    }
    class n extends t2 {
      static value = 1e3 * s2;
    }
    class i extends t2 {
      static value = 60 * n;
    }
    class r extends t2 {
      static value = 60 * i;
    }
    e2.exports = { MILLISECOND: s2, SECOND: n, MINUTE: i, HOUR: r, DAY: class extends t2 {
      static value = 24 * r;
    } };
  }, 875: (e2, t2, s2) => {
    const { AdvancedBase: n } = s2(952), { TService: i } = s2(866), { TeePromise: r } = s2(717), o = (e3) => {
      const t3 = class {
        get label() {
          return e3;
        }
        describe() {
          return e3;
        }
      };
      return t3.name = `Status${e3[0].toUpperCase() + e3.slice(1)}`, t3;
    };
    class a extends n {
      static StatusRegistering = o("registering");
      static StatusPending = class {
        constructor({ waiting_for: e3 }) {
          this.waiting_for = e3;
        }
        get label() {
          return "waiting";
        }
        describe() {
          return `waiting for: ${this.waiting_for.join(", ")}`;
        }
      };
      static StatusInitializing = o("initializing");
      static StatusRunning = class {
        constructor({ start_ts: e3 }) {
          this.start_ts = e3;
        }
        get label() {
          return "running";
        }
        describe() {
          return `running (since ${this.start_ts})`;
        }
      };
      constructor({ context: e3 } = {}) {
        super(), this.context = e3, this.services_l_ = [], this.services_m_ = {}, this.service_infos_ = {}, this.init_listeners_ = [], this.waiting_ = {};
      }
      async register(e3, t3, s3 = {}) {
        var _a2;
        await new Promise((e4) => setTimeout(e4, 0));
        const n2 = { name: e3, instance: t3.create({ parameters: (_a2 = s3.parameters) != null ? _a2 : {}, context: this.context }), status: new this.constructor.StatusRegistering() };
        this.services_l_.push(n2), this.services_m_[e3] = n2, await this.maybe_init_(e3);
      }
      info(e3) {
        return this.services_m_[e3];
      }
      get(e3) {
        const t3 = this.services_m_[e3];
        if (!t3)
          throw new Error(`Service not registered: ${e3}`);
        if (t3.status instanceof this.constructor.StatusRunning)
          return t3.instance;
      }
      async aget(e3) {
        return await this.wait_for_init([e3]), this.get(e3);
      }
      async wait_for_init(e3) {
        let t3;
        await new Promise((s3) => {
          t3 = () => {
            if (0 === this.get_waiting_for_(e3).length) {
              const e4 = this.init_listeners_.indexOf(t3);
              return -1 !== e4 && this.init_listeners_.splice(e4, 1), s3(), true;
            }
          }, t3() || this.init_listeners_.push(t3);
        });
      }
      get_waiting_for_(e3) {
        const t3 = [];
        for (const s3 of e3) {
          const e4 = this.services_m_[s3];
          e4 && e4.status instanceof this.constructor.StatusRunning || t3.push(s3);
        }
        return t3;
      }
      async maybe_init_(e3) {
        const t3 = this.services_m_[e3], s3 = t3.instance.as(i).get_depends(), n2 = this.get_waiting_for_(s3);
        if (0 !== n2.length) {
          for (const t4 of n2)
            (this.waiting_[t4] || (this.waiting_[t4] = /* @__PURE__ */ new Set())).add(e3);
          t3.status = new this.constructor.StatusPending({ waiting_for: n2 });
        } else
          await this.init_service_(e3);
      }
      async init_service_(e3, t3 = {}) {
        const s3 = this.services_m_[e3];
        s3.status = new this.constructor.StatusInitializing();
        const n2 = s3.instance.as(i);
        await n2.init(), s3.status = new this.constructor.StatusRunning({ start_ts: new Date() });
        const r2 = this.waiting_[e3], o2 = [];
        if (r2)
          for (const e4 of r2.values())
            o2.push(this.maybe_init_(e4, { no_init_listeners: true }));
        if (await Promise.all(o2), !t3.no_init_listeners)
          for (const e4 of this.init_listeners_)
            await e4();
      }
    }
    e2.exports = { ServiceManager: a };
  }, 868: (e2) => {
    e2.exports = { TTopics: Symbol("TTopics"), TDetachable: Symbol("TDetachable"), TLogger: Symbol("TLogger"), AS: (e3, t2) => e3.constructor && e3.constructor.IMPLEMENTS && e3.constructor.IMPLEMENTS[t2] ? e3.as(t2) : e3 };
  } }, t = {};
  function s(n) {
    var i = t[n];
    if (void 0 !== i)
      return i.exports;
    var r = t[n] = { exports: {} };
    return e[n](r, r.exports, s), r.exports;
  }
  s.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), (() => {
    var _e2, _t2, _s, _n, _i, _r, _o, _a, _c, _l, _h, _e3, _u, _d, _p, _f, _g, _m, _y, _b, _w, w_fn, _a2, _r2, _b2, _v;
    "use strict";
    async function e2(e3) {
      if ("blob" === e3.responseType) {
        const t4 = e3.getResponseHeader("content-type");
        if (t4.startsWith("application/json")) {
          const t5 = await e3.response.text();
          try {
            return JSON.parse(t5);
          } catch (e4) {
            return t5;
          }
        } else if (t4.startsWith("application/octet-stream"))
          return e3.response;
        return { success: true, result: e3.response };
      }
      const t3 = e3.responseText;
      try {
        return JSON.parse(t3);
      } catch (e4) {
        return t3;
      }
    }
    function t2() {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (e3) => (e3 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e3 / 4).toString(16));
    }
    function n(e3, t3, s2, n2 = "post", i2 = "application/json;charset=UTF-8", r2 = void 0) {
      const o2 = new XMLHttpRequest();
      return o2.open(n2, t3 + e3, true), o2.setRequestHeader("Authorization", "Bearer " + s2), o2.setRequestHeader("Content-Type", i2), o2.responseType = r2 != null ? r2 : "", o2;
    }
    function i(e3, t3, s2) {
      return e3 && "function" == typeof e3 && e3(s2), t3(s2);
    }
    function r(t3, s2, n2, r2, o2) {
      t3.addEventListener("load", function(t4) {
        return async function(t5, s3, n3, i2, r3) {
          var _a3;
          const o3 = await e2(r3);
          return 401 === r3.status ? (s3 && "function" == typeof s3 && s3({ status: 401, message: "Unauthorized" }), i2({ status: 401, message: "Unauthorized" })) : 200 !== r3.status ? (s3 && "function" == typeof s3 && s3(o3), i2(o3)) : (false === o3.success && "permission_denied" === ((_a3 = o3.error) == null ? void 0 : _a3.code) && (await puter.ui.requestPermission({ permission: "driver:puter-image-generation:generate" })).granted, t5 && "function" == typeof t5 && t5(o3), n3(o3));
        }(s2, n2, r2, o2, this);
      }), t3.addEventListener("error", function(e3) {
        return i(n2, o2, this);
      });
    }
    const o = () => {
    };
    class a {
      static callback(e3) {
        return e3 && "function" == typeof e3 ? e3 : void 0;
      }
    }
    function c(e3, t3, s2, n2, i2 = {}) {
      return async function(...r2) {
        let o2 = {}, a2 = {};
        return 1 !== r2.length || "object" != typeof r2[0] || Array.isArray(r2[0]) ? (e3.forEach((e4, t4) => {
          o2[e4] = r2[t4];
        }), a2 = { success: r2[e3.length], error: r2[e3.length + 1] }) : (o2 = { ...r2[0] }, a2 = { success: o2.success, error: o2.error }, delete o2.success, delete o2.error), i2.preprocess && "function" == typeof i2.preprocess && (o2 = i2.preprocess(o2)), await async function(e4, t4, s3, n3, i3, r3) {
          const o3 = new h();
          return l(e4, o3.resolve.bind(o3), o3.reject.bind(o3), t4, s3, n3, i3, void 0, void 0, r3), await o3;
        }(a2, t3, s2, n2, o2, i2);
      };
    }
    async function l(t3 = {}, s2, r2, c2, u2, d2, p2, f2, g2 = "application/json;charset=UTF-8", m2 = {}) {
      var _a3, _b3;
      if (!puter.authToken && "web" === puter.env)
        try {
          await puter.ui.authenticateWithPuter();
        } catch (e3) {
          return r2({ error: { code: "auth_canceled", message: "Authentication canceled" } });
        }
      const y2 = (_a3 = a.callback(t3.success)) != null ? _a3 : o, b2 = (_b3 = a.callback(t3.error)) != null ? _b3 : o, w2 = n("/drivers/call", puter.APIOrigin, puter.authToken, "POST", g2);
      m2.responseType && (w2.responseType = m2.responseType);
      let v2 = false, _2 = null, A2 = 0, k2 = false, I2 = "";
      const T2 = [];
      w2.onreadystatechange = () => {
        if (2 === w2.readyState) {
          if ("application/x-ndjson" !== w2.getResponseHeader("Content-Type"))
            return;
          return v2 = true, s2(async function* () {
            for (; !k2; ) {
              const e3 = new h();
              if (_2 = e3.resolve.bind(e3), await e3, k2)
                break;
              for (; T2.length > 0; ) {
                const e4 = T2.shift();
                "" !== e4.trim() && (yield JSON.parse(e4));
              }
            }
          }());
        }
        4 === w2.readyState && (k2 = true, v2 && (_2 == null ? void 0 : _2()));
      }, w2.onprogress = function() {
        if (!_2)
          return;
        const e3 = w2.responseText.slice(A2);
        A2 = w2.responseText.length;
        let t4 = false;
        for (let s3 = 0; s3 < e3.length; s3++)
          I2 += e3[s3], "\n" === e3[s3] && (t4 = true, T2.push(I2), I2 = "");
        t4 && _2();
      }, w2.addEventListener("load", async function(n2) {
        var _a4;
        if (v2)
          return;
        const i2 = await e2(n2.target);
        if (401 === n2.status || "token_auth_failed" === (i2 == null ? void 0 : i2.code)) {
          if ("token_auth_failed" === (i2 == null ? void 0 : i2.code) && "web" === puter.env)
            try {
              puter.resetAuthToken(), await puter.ui.authenticateWithPuter();
            } catch (e3) {
              return r2({ error: { code: "auth_canceled", message: "Authentication canceled" } });
            }
          return b2 && "function" == typeof b2 && b2({ status: 401, message: "Unauthorized" }), r2({ status: 401, message: "Unauthorized" });
        }
        if (n2.status && 200 !== n2.status)
          return b2(i2), r2(i2);
        {
          if (false === i2.success && "permission_denied" === ((_a4 = i2.error) == null ? void 0 : _a4.code))
            return (await puter.ui.requestPermission({ permission: "driver:" + c2 + ":" + d2 })).granted ? l(t3, s2, r2, c2, d2, p2, f2, g2, m2) : (b2(i2), r2(i2));
          if (false === i2.success)
            return b2(i2), r2(i2);
          let e3 = void 0 !== i2.result ? i2.result : i2;
          return m2.transform && (e3 = await m2.transform(e3)), s2.success && y2(e3), s2(e3);
        }
      }), w2.addEventListener("error", function(e3) {
        return i(b2, r2, this);
      }), w2.send(JSON.stringify({ interface: c2, driver: u2, test_mode: m2 == null ? void 0 : m2.test_mode, method: d2, args: p2 }));
    }
    class h {
      static STATUS_PENDING = {};
      static STATUS_RUNNING = {};
      static STATUS_DONE = {};
      constructor() {
        this.status_ = this.constructor.STATUS_PENDING, this.donePromise = new Promise((e3, t3) => {
          this.doneResolve = e3, this.doneReject = t3;
        });
      }
      get status() {
        return this.status_;
      }
      set status(e3) {
        this.status_ = e3, e3 === this.constructor.STATUS_DONE && this.doneResolve();
      }
      resolve(e3) {
        this.status_ = this.constructor.STATUS_DONE, this.doneResolve(e3);
      }
      awaitDone() {
        return this.donePromise;
      }
      then(e3, t3) {
        return this.donePromise.then(e3, t3);
      }
      reject(e3) {
        this.status_ = this.constructor.STATUS_DONE, this.doneReject(e3);
      }
      onComplete(e3) {
        return this.then(e3);
      }
    }
    async function u(e3) {
      const t3 = new h(), s2 = new FileReader();
      return s2.onloadend = () => t3.resolve(s2.result), s2.readAsDataURL(e3), await t3;
    }
    function d(e3) {
      return new Promise((t3, s2) => {
        const n2 = new FileReader();
        n2.onload = function(e4) {
          t3(e4.target.result);
        }, n2.onerror = function(e4) {
          s2(e4);
        }, n2.readAsDataURL(e3);
      });
    }
    const p = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      user = function(...e3) {
        let t3;
        t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] };
        let s2 = "";
        return (t3 == null ? void 0 : t3.query) && (s2 = "?" + new URLSearchParams(t3.query).toString()), new Promise((e4, i2) => {
          const o2 = n("/whoami" + s2, this.APIOrigin, this.authToken, "get");
          r(o2, t3.success, t3.error, e4, i2), o2.send();
        });
      };
      version = function(...e3) {
        let t3;
        return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] }, new Promise((e4, s2) => {
          const i2 = n("/version", this.APIOrigin, this.authToken, "get");
          r(i2, t3.success, t3.error, e4, s2), i2.send();
        });
      };
    }, f = /* @__PURE__ */ Object.create(null);
    f.open = "0", f.close = "1", f.ping = "2", f.pong = "3", f.message = "4", f.upgrade = "5", f.noop = "6";
    const g = /* @__PURE__ */ Object.create(null);
    Object.keys(f).forEach((e3) => {
      g[f[e3]] = e3;
    });
    const m = { type: "error", data: "parser error" }, y = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob), b = "function" == typeof ArrayBuffer, w = (e3) => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e3) : e3 && e3.buffer instanceof ArrayBuffer, v = ({ type: e3, data: t3 }, s2, n2) => y && t3 instanceof Blob ? s2 ? n2(t3) : _(t3, n2) : b && (t3 instanceof ArrayBuffer || w(t3)) ? s2 ? n2(t3) : _(new Blob([t3]), n2) : n2(f[e3] + (t3 || "")), _ = (e3, t3) => {
      const s2 = new FileReader();
      return s2.onload = function() {
        const e4 = s2.result.split(",")[1];
        t3("b" + (e4 || ""));
      }, s2.readAsDataURL(e3);
    };
    function A(e3) {
      return e3 instanceof Uint8Array ? e3 : e3 instanceof ArrayBuffer ? new Uint8Array(e3) : new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength);
    }
    let k;
    const I = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256);
    for (let e3 = 0; e3 < 64; e3++)
      I["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(e3)] = e3;
    const T = "function" == typeof ArrayBuffer, x = (e3, t3) => {
      if ("string" != typeof e3)
        return { type: "message", data: P(e3, t3) };
      const s2 = e3.charAt(0);
      return "b" === s2 ? { type: "message", data: E(e3.substring(1), t3) } : g[s2] ? e3.length > 1 ? { type: g[s2], data: e3.substring(1) } : { type: g[s2] } : m;
    }, E = (e3, t3) => {
      if (T) {
        const s2 = ((e4) => {
          let t4, s3, n2, i2, r2, o2 = 0.75 * e4.length, a2 = e4.length, c2 = 0;
          "=" === e4[e4.length - 1] && (o2--, "=" === e4[e4.length - 2] && o2--);
          const l2 = new ArrayBuffer(o2), h2 = new Uint8Array(l2);
          for (t4 = 0; t4 < a2; t4 += 4)
            s3 = I[e4.charCodeAt(t4)], n2 = I[e4.charCodeAt(t4 + 1)], i2 = I[e4.charCodeAt(t4 + 2)], r2 = I[e4.charCodeAt(t4 + 3)], h2[c2++] = s3 << 2 | n2 >> 4, h2[c2++] = (15 & n2) << 4 | i2 >> 2, h2[c2++] = (3 & i2) << 6 | 63 & r2;
          return l2;
        })(e3);
        return P(s2, t3);
      }
      return { base64: true, data: e3 };
    }, P = (e3, t3) => "blob" === t3 ? e3 instanceof Blob ? e3 : new Blob([e3]) : e3 instanceof ArrayBuffer ? e3 : e3.buffer, S = String.fromCharCode(30);
    function O() {
      return new TransformStream({ transform(e3, t3) {
        !function(e4, t4) {
          y && e4.data instanceof Blob ? e4.data.arrayBuffer().then(A).then(t4) : b && (e4.data instanceof ArrayBuffer || w(e4.data)) ? t4(A(e4.data)) : v(e4, false, (e5) => {
            k || (k = new TextEncoder()), t4(k.encode(e5));
          });
        }(e3, (s2) => {
          const n2 = s2.length;
          let i2;
          if (n2 < 126)
            i2 = new Uint8Array(1), new DataView(i2.buffer).setUint8(0, n2);
          else if (n2 < 65536) {
            i2 = new Uint8Array(3);
            const e4 = new DataView(i2.buffer);
            e4.setUint8(0, 126), e4.setUint16(1, n2);
          } else {
            i2 = new Uint8Array(9);
            const e4 = new DataView(i2.buffer);
            e4.setUint8(0, 127), e4.setBigUint64(1, BigInt(n2));
          }
          e3.data && "string" != typeof e3.data && (i2[0] |= 128), t3.enqueue(i2), t3.enqueue(s2);
        });
      } });
    }
    let C;
    function D(e3) {
      return e3.reduce((e4, t3) => e4 + t3.length, 0);
    }
    function M(e3, t3) {
      if (e3[0].length === t3)
        return e3.shift();
      const s2 = new Uint8Array(t3);
      let n2 = 0;
      for (let i2 = 0; i2 < t3; i2++)
        s2[i2] = e3[0][n2++], n2 === e3[0].length && (e3.shift(), n2 = 0);
      return e3.length && n2 < e3[0].length && (e3[0] = e3[0].slice(n2)), s2;
    }
    function L(e3) {
      if (e3)
        return function(e4) {
          for (var t3 in L.prototype)
            e4[t3] = L.prototype[t3];
          return e4;
        }(e3);
    }
    L.prototype.on = L.prototype.addEventListener = function(e3, t3) {
      return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e3] = this._callbacks["$" + e3] || []).push(t3), this;
    }, L.prototype.once = function(e3, t3) {
      function s2() {
        this.off(e3, s2), t3.apply(this, arguments);
      }
      return s2.fn = t3, this.on(e3, s2), this;
    }, L.prototype.off = L.prototype.removeListener = L.prototype.removeAllListeners = L.prototype.removeEventListener = function(e3, t3) {
      if (this._callbacks = this._callbacks || {}, 0 == arguments.length)
        return this._callbacks = {}, this;
      var s2, n2 = this._callbacks["$" + e3];
      if (!n2)
        return this;
      if (1 == arguments.length)
        return delete this._callbacks["$" + e3], this;
      for (var i2 = 0; i2 < n2.length; i2++)
        if ((s2 = n2[i2]) === t3 || s2.fn === t3) {
          n2.splice(i2, 1);
          break;
        }
      return 0 === n2.length && delete this._callbacks["$" + e3], this;
    }, L.prototype.emit = function(e3) {
      this._callbacks = this._callbacks || {};
      for (var t3 = new Array(arguments.length - 1), s2 = this._callbacks["$" + e3], n2 = 1; n2 < arguments.length; n2++)
        t3[n2 - 1] = arguments[n2];
      if (s2) {
        n2 = 0;
        for (var i2 = (s2 = s2.slice(0)).length; n2 < i2; ++n2)
          s2[n2].apply(this, t3);
      }
      return this;
    }, L.prototype.emitReserved = L.prototype.emit, L.prototype.listeners = function(e3) {
      return this._callbacks = this._callbacks || {}, this._callbacks["$" + e3] || [];
    }, L.prototype.hasListeners = function(e3) {
      return !!this.listeners(e3).length;
    };
    const R = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")();
    function U(e3, ...t3) {
      return t3.reduce((t4, s2) => (e3.hasOwnProperty(s2) && (t4[s2] = e3[s2]), t4), {});
    }
    const B = R.setTimeout, N = R.clearTimeout;
    function q(e3, t3) {
      t3.useNativeTimers ? (e3.setTimeoutFn = B.bind(R), e3.clearTimeoutFn = N.bind(R)) : (e3.setTimeoutFn = R.setTimeout.bind(R), e3.clearTimeoutFn = R.clearTimeout.bind(R));
    }
    class F extends Error {
      constructor(e3, t3, s2) {
        super(e3), this.description = t3, this.context = s2, this.type = "TransportError";
      }
    }
    class j extends L {
      constructor(e3) {
        super(), this.writable = false, q(this, e3), this.opts = e3, this.query = e3.query, this.socket = e3.socket;
      }
      onError(e3, t3, s2) {
        return super.emitReserved("error", new F(e3, t3, s2)), this;
      }
      open() {
        return this.readyState = "opening", this.doOpen(), this;
      }
      close() {
        return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this;
      }
      send(e3) {
        "open" === this.readyState && this.write(e3);
      }
      onOpen() {
        this.readyState = "open", this.writable = true, super.emitReserved("open");
      }
      onData(e3) {
        const t3 = x(e3, this.socket.binaryType);
        this.onPacket(t3);
      }
      onPacket(e3) {
        super.emitReserved("packet", e3);
      }
      onClose(e3) {
        this.readyState = "closed", super.emitReserved("close", e3);
      }
      pause(e3) {
      }
      createUri(e3, t3 = {}) {
        return e3 + "://" + this._hostname() + this._port() + this.opts.path + this._query(t3);
      }
      _hostname() {
        const e3 = this.opts.hostname;
        return -1 === e3.indexOf(":") ? e3 : "[" + e3 + "]";
      }
      _port() {
        return this.opts.port && (this.opts.secure && Number(443 !== this.opts.port) || !this.opts.secure && 80 !== Number(this.opts.port)) ? ":" + this.opts.port : "";
      }
      _query(e3) {
        const t3 = function(e4) {
          let t4 = "";
          for (let s2 in e4)
            e4.hasOwnProperty(s2) && (t4.length && (t4 += "&"), t4 += encodeURIComponent(s2) + "=" + encodeURIComponent(e4[s2]));
          return t4;
        }(e3);
        return t3.length ? "?" + t3 : "";
      }
    }
    const z = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), W = 64, X = {};
    let V, G = 0, K = 0;
    function Y(e3) {
      let t3 = "";
      do {
        t3 = z[e3 % W] + t3, e3 = Math.floor(e3 / W);
      } while (e3 > 0);
      return t3;
    }
    function H() {
      const e3 = Y(+new Date());
      return e3 !== V ? (G = 0, V = e3) : e3 + "." + Y(G++);
    }
    for (; K < W; K++)
      X[z[K]] = K;
    let Q = false;
    try {
      Q = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    } catch (f2) {
    }
    const Z = Q;
    function J(e3) {
      const t3 = e3.xdomain;
      try {
        if ("undefined" != typeof XMLHttpRequest && (!t3 || Z))
          return new XMLHttpRequest();
      } catch (e4) {
      }
      if (!t3)
        try {
          return new R[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e4) {
        }
    }
    function $() {
    }
    const ee = null != new J({ xdomain: false }).responseType;
    class te extends L {
      constructor(e3, t3) {
        super(), q(this, t3), this.opts = t3, this.method = t3.method || "GET", this.uri = e3, this.data = void 0 !== t3.data ? t3.data : null, this.create();
      }
      create() {
        var e3;
        const t3 = U(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        t3.xdomain = !!this.opts.xd;
        const s2 = this.xhr = new J(t3);
        try {
          s2.open(this.method, this.uri, true);
          try {
            if (this.opts.extraHeaders) {
              s2.setDisableHeaderCheck && s2.setDisableHeaderCheck(true);
              for (let e4 in this.opts.extraHeaders)
                this.opts.extraHeaders.hasOwnProperty(e4) && s2.setRequestHeader(e4, this.opts.extraHeaders[e4]);
            }
          } catch (e4) {
          }
          if ("POST" === this.method)
            try {
              s2.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e4) {
            }
          try {
            s2.setRequestHeader("Accept", "*/*");
          } catch (e4) {
          }
          null === (e3 = this.opts.cookieJar) || void 0 === e3 || e3.addCookies(s2), "withCredentials" in s2 && (s2.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (s2.timeout = this.opts.requestTimeout), s2.onreadystatechange = () => {
            var e4;
            3 === s2.readyState && (null === (e4 = this.opts.cookieJar) || void 0 === e4 || e4.parseCookies(s2)), 4 === s2.readyState && (200 === s2.status || 1223 === s2.status ? this.onLoad() : this.setTimeoutFn(() => {
              this.onError("number" == typeof s2.status ? s2.status : 0);
            }, 0));
          }, s2.send(this.data);
        } catch (e4) {
          return void this.setTimeoutFn(() => {
            this.onError(e4);
          }, 0);
        }
        "undefined" != typeof document && (this.index = te.requestsCount++, te.requests[this.index] = this);
      }
      onError(e3) {
        this.emitReserved("error", e3, this.xhr), this.cleanup(true);
      }
      cleanup(e3) {
        if (void 0 !== this.xhr && null !== this.xhr) {
          if (this.xhr.onreadystatechange = $, e3)
            try {
              this.xhr.abort();
            } catch (e4) {
            }
          "undefined" != typeof document && delete te.requests[this.index], this.xhr = null;
        }
      }
      onLoad() {
        const e3 = this.xhr.responseText;
        null !== e3 && (this.emitReserved("data", e3), this.emitReserved("success"), this.cleanup());
      }
      abort() {
        this.cleanup();
      }
    }
    function se() {
      for (let e3 in te.requests)
        te.requests.hasOwnProperty(e3) && te.requests[e3].abort();
    }
    te.requestsCount = 0, te.requests = {}, "undefined" != typeof document && ("function" == typeof attachEvent ? attachEvent("onunload", se) : "function" == typeof addEventListener && addEventListener("onpagehide" in R ? "pagehide" : "unload", se, false));
    const ne = "function" == typeof Promise && "function" == typeof Promise.resolve ? (e3) => Promise.resolve().then(e3) : (e3, t3) => t3(e3, 0), ie = R.WebSocket || R.MozWebSocket, re = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), oe = { websocket: class extends j {
      constructor(e3) {
        super(e3), this.supportsBinary = !e3.forceBase64;
      }
      get name() {
        return "websocket";
      }
      doOpen() {
        if (!this.check())
          return;
        const e3 = this.uri(), t3 = this.opts.protocols, s2 = re ? {} : U(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (s2.headers = this.opts.extraHeaders);
        try {
          this.ws = re ? new ie(e3, t3, s2) : t3 ? new ie(e3, t3) : new ie(e3);
        } catch (e4) {
          return this.emitReserved("error", e4);
        }
        this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
      }
      addEventListeners() {
        this.ws.onopen = () => {
          this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
        }, this.ws.onclose = (e3) => this.onClose({ description: "websocket connection closed", context: e3 }), this.ws.onmessage = (e3) => this.onData(e3.data), this.ws.onerror = (e3) => this.onError("websocket error", e3);
      }
      write(e3) {
        this.writable = false;
        for (let t3 = 0; t3 < e3.length; t3++) {
          const s2 = e3[t3], n2 = t3 === e3.length - 1;
          v(s2, this.supportsBinary, (e4) => {
            try {
              this.ws.send(e4);
            } catch (e5) {
            }
            n2 && ne(() => {
              this.writable = true, this.emitReserved("drain");
            }, this.setTimeoutFn);
          });
        }
      }
      doClose() {
        void 0 !== this.ws && (this.ws.close(), this.ws = null);
      }
      uri() {
        const e3 = this.opts.secure ? "wss" : "ws", t3 = this.query || {};
        return this.opts.timestampRequests && (t3[this.opts.timestampParam] = H()), this.supportsBinary || (t3.b64 = 1), this.createUri(e3, t3);
      }
      check() {
        return !!ie;
      }
    }, webtransport: class extends j {
      get name() {
        return "webtransport";
      }
      doOpen() {
        "function" == typeof WebTransport && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
          this.onClose();
        }).catch((e3) => {
          this.onError("webtransport error", e3);
        }), this.transport.ready.then(() => {
          this.transport.createBidirectionalStream().then((e3) => {
            const t3 = function(e4, t4) {
              C || (C = new TextDecoder());
              const s3 = [];
              let n3 = 0, i3 = -1, r3 = false;
              return new TransformStream({ transform(o2, a2) {
                for (s3.push(o2); ; ) {
                  if (0 === n3) {
                    if (D(s3) < 1)
                      break;
                    const e5 = M(s3, 1);
                    r3 = !(128 & ~e5[0]), i3 = 127 & e5[0], n3 = i3 < 126 ? 3 : 126 === i3 ? 1 : 2;
                  } else if (1 === n3) {
                    if (D(s3) < 2)
                      break;
                    const e5 = M(s3, 2);
                    i3 = new DataView(e5.buffer, e5.byteOffset, e5.length).getUint16(0), n3 = 3;
                  } else if (2 === n3) {
                    if (D(s3) < 8)
                      break;
                    const e5 = M(s3, 8), t5 = new DataView(e5.buffer, e5.byteOffset, e5.length), r4 = t5.getUint32(0);
                    if (r4 > Math.pow(2, 21) - 1) {
                      a2.enqueue(m);
                      break;
                    }
                    i3 = r4 * Math.pow(2, 32) + t5.getUint32(4), n3 = 3;
                  } else {
                    if (D(s3) < i3)
                      break;
                    const e5 = M(s3, i3);
                    a2.enqueue(x(r3 ? e5 : C.decode(e5), t4)), n3 = 0;
                  }
                  if (0 === i3 || i3 > e4) {
                    a2.enqueue(m);
                    break;
                  }
                }
              } });
            }(Number.MAX_SAFE_INTEGER, this.socket.binaryType), s2 = e3.readable.pipeThrough(t3).getReader(), n2 = O();
            n2.readable.pipeTo(e3.writable), this.writer = n2.writable.getWriter();
            const i2 = () => {
              s2.read().then(({ done: e4, value: t4 }) => {
                e4 || (this.onPacket(t4), i2());
              }).catch((e4) => {
              });
            };
            i2();
            const r2 = { type: "open" };
            this.query.sid && (r2.data = `{"sid":"${this.query.sid}"}`), this.writer.write(r2).then(() => this.onOpen());
          });
        }));
      }
      write(e3) {
        this.writable = false;
        for (let t3 = 0; t3 < e3.length; t3++) {
          const s2 = e3[t3], n2 = t3 === e3.length - 1;
          this.writer.write(s2).then(() => {
            n2 && ne(() => {
              this.writable = true, this.emitReserved("drain");
            }, this.setTimeoutFn);
          });
        }
      }
      doClose() {
        var e3;
        null === (e3 = this.transport) || void 0 === e3 || e3.close();
      }
    }, polling: class extends j {
      constructor(e3) {
        if (super(e3), this.polling = false, "undefined" != typeof location) {
          const t4 = "https:" === location.protocol;
          let s2 = location.port;
          s2 || (s2 = t4 ? "443" : "80"), this.xd = "undefined" != typeof location && e3.hostname !== location.hostname || s2 !== e3.port;
        }
        const t3 = e3 && e3.forceBase64;
        this.supportsBinary = ee && !t3, this.opts.withCredentials && (this.cookieJar = void 0);
      }
      get name() {
        return "polling";
      }
      doOpen() {
        this.poll();
      }
      pause(e3) {
        this.readyState = "pausing";
        const t3 = () => {
          this.readyState = "paused", e3();
        };
        if (this.polling || !this.writable) {
          let e4 = 0;
          this.polling && (e4++, this.once("pollComplete", function() {
            --e4 || t3();
          })), this.writable || (e4++, this.once("drain", function() {
            --e4 || t3();
          }));
        } else
          t3();
      }
      poll() {
        this.polling = true, this.doPoll(), this.emitReserved("poll");
      }
      onData(e3) {
        ((e4, t3) => {
          const s2 = e4.split(S), n2 = [];
          for (let e5 = 0; e5 < s2.length; e5++) {
            const i2 = x(s2[e5], t3);
            if (n2.push(i2), "error" === i2.type)
              break;
          }
          return n2;
        })(e3, this.socket.binaryType).forEach((e4) => {
          if ("opening" === this.readyState && "open" === e4.type && this.onOpen(), "close" === e4.type)
            return this.onClose({ description: "transport closed by the server" }), false;
          this.onPacket(e4);
        }), "closed" !== this.readyState && (this.polling = false, this.emitReserved("pollComplete"), "open" === this.readyState && this.poll());
      }
      doClose() {
        const e3 = () => {
          this.write([{ type: "close" }]);
        };
        "open" === this.readyState ? e3() : this.once("open", e3);
      }
      write(e3) {
        this.writable = false, ((e4, t3) => {
          const s2 = e4.length, n2 = new Array(s2);
          let i2 = 0;
          e4.forEach((e5, r2) => {
            v(e5, false, (e6) => {
              n2[r2] = e6, ++i2 === s2 && t3(n2.join(S));
            });
          });
        })(e3, (e4) => {
          this.doWrite(e4, () => {
            this.writable = true, this.emitReserved("drain");
          });
        });
      }
      uri() {
        const e3 = this.opts.secure ? "https" : "http", t3 = this.query || {};
        return false !== this.opts.timestampRequests && (t3[this.opts.timestampParam] = H()), this.supportsBinary || t3.sid || (t3.b64 = 1), this.createUri(e3, t3);
      }
      request(e3 = {}) {
        return Object.assign(e3, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new te(this.uri(), e3);
      }
      doWrite(e3, t3) {
        const s2 = this.request({ method: "POST", data: e3 });
        s2.on("success", t3), s2.on("error", (e4, t4) => {
          this.onError("xhr post error", e4, t4);
        });
      }
      doPoll() {
        const e3 = this.request();
        e3.on("data", this.onData.bind(this)), e3.on("error", (e4, t3) => {
          this.onError("xhr poll error", e4, t3);
        }), this.pollXhr = e3;
      }
    } }, ae = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, ce = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
    function le(e3) {
      const t3 = e3, s2 = e3.indexOf("["), n2 = e3.indexOf("]");
      -1 != s2 && -1 != n2 && (e3 = e3.substring(0, s2) + e3.substring(s2, n2).replace(/:/g, ";") + e3.substring(n2, e3.length));
      let i2 = ae.exec(e3 || ""), r2 = {}, o2 = 14;
      for (; o2--; )
        r2[ce[o2]] = i2[o2] || "";
      return -1 != s2 && -1 != n2 && (r2.source = t3, r2.host = r2.host.substring(1, r2.host.length - 1).replace(/;/g, ":"), r2.authority = r2.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), r2.ipv6uri = true), r2.pathNames = function(e4, t4) {
        const s3 = t4.replace(/\/{2,9}/g, "/").split("/");
        return "/" != t4.slice(0, 1) && 0 !== t4.length || s3.splice(0, 1), "/" == t4.slice(-1) && s3.splice(s3.length - 1, 1), s3;
      }(0, r2.path), r2.queryKey = function(e4, t4) {
        const s3 = {};
        return t4.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(e5, t5, n3) {
          t5 && (s3[t5] = n3);
        }), s3;
      }(0, r2.query), r2;
    }
    class he extends L {
      constructor(e3, t3 = {}) {
        super(), this.binaryType = "arraybuffer", this.writeBuffer = [], e3 && "object" == typeof e3 && (t3 = e3, e3 = null), e3 ? (e3 = le(e3), t3.hostname = e3.host, t3.secure = "https" === e3.protocol || "wss" === e3.protocol, t3.port = e3.port, e3.query && (t3.query = e3.query)) : t3.host && (t3.hostname = le(t3.host).host), q(this, t3), this.secure = null != t3.secure ? t3.secure : "undefined" != typeof location && "https:" === location.protocol, t3.hostname && !t3.port && (t3.port = this.secure ? "443" : "80"), this.hostname = t3.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = t3.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t3.transports || ["polling", "websocket", "webtransport"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: false, withCredentials: false, upgrade: true, timestampParam: "t", rememberUpgrade: false, addTrailingSlash: true, rejectUnauthorized: true, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: false }, t3), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), "string" == typeof this.opts.query && (this.opts.query = function(e4) {
          let t4 = {}, s2 = e4.split("&");
          for (let e5 = 0, n2 = s2.length; e5 < n2; e5++) {
            let n3 = s2[e5].split("=");
            t4[decodeURIComponent(n3[0])] = decodeURIComponent(n3[1]);
          }
          return t4;
        }(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, "function" == typeof addEventListener && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
          this.transport && (this.transport.removeAllListeners(), this.transport.close());
        }, addEventListener("beforeunload", this.beforeunloadEventListener, false)), "localhost" !== this.hostname && (this.offlineEventListener = () => {
          this.onClose("transport close", { description: "network connection lost" });
        }, addEventListener("offline", this.offlineEventListener, false))), this.open();
      }
      createTransport(e3) {
        const t3 = Object.assign({}, this.opts.query);
        t3.EIO = 4, t3.transport = e3, this.id && (t3.sid = this.id);
        const s2 = Object.assign({}, this.opts, { query: t3, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }, this.opts.transportOptions[e3]);
        return new oe[e3](s2);
      }
      open() {
        let e3;
        if (this.opts.rememberUpgrade && he.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket"))
          e3 = "websocket";
        else {
          if (0 === this.transports.length)
            return void this.setTimeoutFn(() => {
              this.emitReserved("error", "No transports available");
            }, 0);
          e3 = this.transports[0];
        }
        this.readyState = "opening";
        try {
          e3 = this.createTransport(e3);
        } catch (e4) {
          return this.transports.shift(), void this.open();
        }
        e3.open(), this.setTransport(e3);
      }
      setTransport(e3) {
        this.transport && this.transport.removeAllListeners(), this.transport = e3, e3.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e4) => this.onClose("transport close", e4));
      }
      probe(e3) {
        let t3 = this.createTransport(e3), s2 = false;
        he.priorWebsocketSuccess = false;
        const n2 = () => {
          s2 || (t3.send([{ type: "ping", data: "probe" }]), t3.once("packet", (e4) => {
            if (!s2)
              if ("pong" === e4.type && "probe" === e4.data) {
                if (this.upgrading = true, this.emitReserved("upgrading", t3), !t3)
                  return;
                he.priorWebsocketSuccess = "websocket" === t3.name, this.transport.pause(() => {
                  s2 || "closed" !== this.readyState && (l2(), this.setTransport(t3), t3.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t3), t3 = null, this.upgrading = false, this.flush());
                });
              } else {
                const e5 = new Error("probe error");
                e5.transport = t3.name, this.emitReserved("upgradeError", e5);
              }
          }));
        };
        function i2() {
          s2 || (s2 = true, l2(), t3.close(), t3 = null);
        }
        const r2 = (e4) => {
          const s3 = new Error("probe error: " + e4);
          s3.transport = t3.name, i2(), this.emitReserved("upgradeError", s3);
        };
        function o2() {
          r2("transport closed");
        }
        function a2() {
          r2("socket closed");
        }
        function c2(e4) {
          t3 && e4.name !== t3.name && i2();
        }
        const l2 = () => {
          t3.removeListener("open", n2), t3.removeListener("error", r2), t3.removeListener("close", o2), this.off("close", a2), this.off("upgrading", c2);
        };
        t3.once("open", n2), t3.once("error", r2), t3.once("close", o2), this.once("close", a2), this.once("upgrading", c2), -1 !== this.upgrades.indexOf("webtransport") && "webtransport" !== e3 ? this.setTimeoutFn(() => {
          s2 || t3.open();
        }, 200) : t3.open();
      }
      onOpen() {
        if (this.readyState = "open", he.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved("open"), this.flush(), "open" === this.readyState && this.opts.upgrade) {
          let e3 = 0;
          const t3 = this.upgrades.length;
          for (; e3 < t3; e3++)
            this.probe(this.upgrades[e3]);
        }
      }
      onPacket(e3) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState)
          switch (this.emitReserved("packet", e3), this.emitReserved("heartbeat"), this.resetPingTimeout(), e3.type) {
            case "open":
              this.onHandshake(JSON.parse(e3.data));
              break;
            case "ping":
              this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
              break;
            case "error":
              const t3 = new Error("server error");
              t3.code = e3.data, this.onError(t3);
              break;
            case "message":
              this.emitReserved("data", e3.data), this.emitReserved("message", e3.data);
          }
      }
      onHandshake(e3) {
        this.emitReserved("handshake", e3), this.id = e3.sid, this.transport.query.sid = e3.sid, this.upgrades = this.filterUpgrades(e3.upgrades), this.pingInterval = e3.pingInterval, this.pingTimeout = e3.pingTimeout, this.maxPayload = e3.maxPayload, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout();
      }
      resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
      }
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush();
      }
      flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          const e3 = this.getWritablePackets();
          this.transport.send(e3), this.prevBufferLen = e3.length, this.emitReserved("flush");
        }
      }
      getWritablePackets() {
        if (!(this.maxPayload && "polling" === this.transport.name && this.writeBuffer.length > 1))
          return this.writeBuffer;
        let e3 = 1;
        for (let s2 = 0; s2 < this.writeBuffer.length; s2++) {
          const n2 = this.writeBuffer[s2].data;
          if (n2 && (e3 += "string" == typeof (t3 = n2) ? function(e4) {
            let t4 = 0, s3 = 0;
            for (let n3 = 0, i2 = e4.length; n3 < i2; n3++)
              t4 = e4.charCodeAt(n3), t4 < 128 ? s3 += 1 : t4 < 2048 ? s3 += 2 : t4 < 55296 || t4 >= 57344 ? s3 += 3 : (n3++, s3 += 4);
            return s3;
          }(t3) : Math.ceil(1.33 * (t3.byteLength || t3.size))), s2 > 0 && e3 > this.maxPayload)
            return this.writeBuffer.slice(0, s2);
          e3 += 2;
        }
        var t3;
        return this.writeBuffer;
      }
      write(e3, t3, s2) {
        return this.sendPacket("message", e3, t3, s2), this;
      }
      send(e3, t3, s2) {
        return this.sendPacket("message", e3, t3, s2), this;
      }
      sendPacket(e3, t3, s2, n2) {
        if ("function" == typeof t3 && (n2 = t3, t3 = void 0), "function" == typeof s2 && (n2 = s2, s2 = null), "closing" === this.readyState || "closed" === this.readyState)
          return;
        (s2 = s2 || {}).compress = false !== s2.compress;
        const i2 = { type: e3, data: t3, options: s2 };
        this.emitReserved("packetCreate", i2), this.writeBuffer.push(i2), n2 && this.once("flush", n2), this.flush();
      }
      close() {
        const e3 = () => {
          this.onClose("forced close"), this.transport.close();
        }, t3 = () => {
          this.off("upgrade", t3), this.off("upgradeError", t3), e3();
        }, s2 = () => {
          this.once("upgrade", t3), this.once("upgradeError", t3);
        };
        return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
          this.upgrading ? s2() : e3();
        }) : this.upgrading ? s2() : e3()), this;
      }
      onError(e3) {
        he.priorWebsocketSuccess = false, this.emitReserved("error", e3), this.onClose("transport error", e3);
      }
      onClose(e3, t3) {
        "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && (removeEventListener("beforeunload", this.beforeunloadEventListener, false), removeEventListener("offline", this.offlineEventListener, false)), this.readyState = "closed", this.id = null, this.emitReserved("close", e3, t3), this.writeBuffer = [], this.prevBufferLen = 0);
      }
      filterUpgrades(e3) {
        const t3 = [];
        let s2 = 0;
        const n2 = e3.length;
        for (; s2 < n2; s2++)
          ~this.transports.indexOf(e3[s2]) && t3.push(e3[s2]);
        return t3;
      }
    }
    he.protocol = 4;
    const ue = "function" == typeof ArrayBuffer, de = (e3) => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e3) : e3.buffer instanceof ArrayBuffer, pe = Object.prototype.toString, fe = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === pe.call(Blob), ge = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === pe.call(File);
    function me(e3) {
      return ue && (e3 instanceof ArrayBuffer || de(e3)) || fe && e3 instanceof Blob || ge && e3 instanceof File;
    }
    function ye(e3, t3) {
      if (!e3 || "object" != typeof e3)
        return false;
      if (Array.isArray(e3)) {
        for (let t4 = 0, s2 = e3.length; t4 < s2; t4++)
          if (ye(e3[t4]))
            return true;
        return false;
      }
      if (me(e3))
        return true;
      if (e3.toJSON && "function" == typeof e3.toJSON && 1 === arguments.length)
        return ye(e3.toJSON(), true);
      for (const t4 in e3)
        if (Object.prototype.hasOwnProperty.call(e3, t4) && ye(e3[t4]))
          return true;
      return false;
    }
    function be(e3) {
      const t3 = [], s2 = e3.data, n2 = e3;
      return n2.data = we(s2, t3), n2.attachments = t3.length, { packet: n2, buffers: t3 };
    }
    function we(e3, t3) {
      if (!e3)
        return e3;
      if (me(e3)) {
        const s2 = { _placeholder: true, num: t3.length };
        return t3.push(e3), s2;
      }
      if (Array.isArray(e3)) {
        const s2 = new Array(e3.length);
        for (let n2 = 0; n2 < e3.length; n2++)
          s2[n2] = we(e3[n2], t3);
        return s2;
      }
      if ("object" == typeof e3 && !(e3 instanceof Date)) {
        const s2 = {};
        for (const n2 in e3)
          Object.prototype.hasOwnProperty.call(e3, n2) && (s2[n2] = we(e3[n2], t3));
        return s2;
      }
      return e3;
    }
    function ve(e3, t3) {
      return e3.data = _e(e3.data, t3), delete e3.attachments, e3;
    }
    function _e(e3, t3) {
      if (!e3)
        return e3;
      if (e3 && true === e3._placeholder) {
        if ("number" == typeof e3.num && e3.num >= 0 && e3.num < t3.length)
          return t3[e3.num];
        throw new Error("illegal attachments");
      }
      if (Array.isArray(e3))
        for (let s2 = 0; s2 < e3.length; s2++)
          e3[s2] = _e(e3[s2], t3);
      else if ("object" == typeof e3)
        for (const s2 in e3)
          Object.prototype.hasOwnProperty.call(e3, s2) && (e3[s2] = _e(e3[s2], t3));
      return e3;
    }
    const Ae = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"];
    var ke;
    function Ie(e3) {
      return "[object Object]" === Object.prototype.toString.call(e3);
    }
    !function(e3) {
      e3[e3.CONNECT = 0] = "CONNECT", e3[e3.DISCONNECT = 1] = "DISCONNECT", e3[e3.EVENT = 2] = "EVENT", e3[e3.ACK = 3] = "ACK", e3[e3.CONNECT_ERROR = 4] = "CONNECT_ERROR", e3[e3.BINARY_EVENT = 5] = "BINARY_EVENT", e3[e3.BINARY_ACK = 6] = "BINARY_ACK";
    }(ke || (ke = {}));
    class Te extends L {
      constructor(e3) {
        super(), this.reviver = e3;
      }
      add(e3) {
        let t3;
        if ("string" == typeof e3) {
          if (this.reconstructor)
            throw new Error("got plaintext data when reconstructing a packet");
          t3 = this.decodeString(e3);
          const s2 = t3.type === ke.BINARY_EVENT;
          s2 || t3.type === ke.BINARY_ACK ? (t3.type = s2 ? ke.EVENT : ke.ACK, this.reconstructor = new xe(t3), 0 === t3.attachments && super.emitReserved("decoded", t3)) : super.emitReserved("decoded", t3);
        } else {
          if (!me(e3) && !e3.base64)
            throw new Error("Unknown type: " + e3);
          if (!this.reconstructor)
            throw new Error("got binary data when not reconstructing a packet");
          t3 = this.reconstructor.takeBinaryData(e3), t3 && (this.reconstructor = null, super.emitReserved("decoded", t3));
        }
      }
      decodeString(e3) {
        let t3 = 0;
        const s2 = { type: Number(e3.charAt(0)) };
        if (void 0 === ke[s2.type])
          throw new Error("unknown packet type " + s2.type);
        if (s2.type === ke.BINARY_EVENT || s2.type === ke.BINARY_ACK) {
          const n3 = t3 + 1;
          for (; "-" !== e3.charAt(++t3) && t3 != e3.length; )
            ;
          const i2 = e3.substring(n3, t3);
          if (i2 != Number(i2) || "-" !== e3.charAt(t3))
            throw new Error("Illegal attachments");
          s2.attachments = Number(i2);
        }
        if ("/" === e3.charAt(t3 + 1)) {
          const n3 = t3 + 1;
          for (; ++t3 && "," !== e3.charAt(t3) && t3 !== e3.length; )
            ;
          s2.nsp = e3.substring(n3, t3);
        } else
          s2.nsp = "/";
        const n2 = e3.charAt(t3 + 1);
        if ("" !== n2 && Number(n2) == n2) {
          const n3 = t3 + 1;
          for (; ++t3; ) {
            const s3 = e3.charAt(t3);
            if (null == s3 || Number(s3) != s3) {
              --t3;
              break;
            }
            if (t3 === e3.length)
              break;
          }
          s2.id = Number(e3.substring(n3, t3 + 1));
        }
        if (e3.charAt(++t3)) {
          const n3 = this.tryParse(e3.substr(t3));
          if (!Te.isPayloadValid(s2.type, n3))
            throw new Error("invalid payload");
          s2.data = n3;
        }
        return s2;
      }
      tryParse(e3) {
        try {
          return JSON.parse(e3, this.reviver);
        } catch (e4) {
          return false;
        }
      }
      static isPayloadValid(e3, t3) {
        switch (e3) {
          case ke.CONNECT:
            return Ie(t3);
          case ke.DISCONNECT:
            return void 0 === t3;
          case ke.CONNECT_ERROR:
            return "string" == typeof t3 || Ie(t3);
          case ke.EVENT:
          case ke.BINARY_EVENT:
            return Array.isArray(t3) && ("number" == typeof t3[0] || "string" == typeof t3[0] && -1 === Ae.indexOf(t3[0]));
          case ke.ACK:
          case ke.BINARY_ACK:
            return Array.isArray(t3);
        }
      }
      destroy() {
        this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
      }
    }
    class xe {
      constructor(e3) {
        this.packet = e3, this.buffers = [], this.reconPack = e3;
      }
      takeBinaryData(e3) {
        if (this.buffers.push(e3), this.buffers.length === this.reconPack.attachments) {
          const e4 = ve(this.reconPack, this.buffers);
          return this.finishedReconstruction(), e4;
        }
        return null;
      }
      finishedReconstruction() {
        this.reconPack = null, this.buffers = [];
      }
    }
    var Ee = Object.freeze({ __proto__: null, protocol: 5, get PacketType() {
      return ke;
    }, Encoder: class {
      constructor(e3) {
        this.replacer = e3;
      }
      encode(e3) {
        return e3.type !== ke.EVENT && e3.type !== ke.ACK || !ye(e3) ? [this.encodeAsString(e3)] : this.encodeAsBinary({ type: e3.type === ke.EVENT ? ke.BINARY_EVENT : ke.BINARY_ACK, nsp: e3.nsp, data: e3.data, id: e3.id });
      }
      encodeAsString(e3) {
        let t3 = "" + e3.type;
        return e3.type !== ke.BINARY_EVENT && e3.type !== ke.BINARY_ACK || (t3 += e3.attachments + "-"), e3.nsp && "/" !== e3.nsp && (t3 += e3.nsp + ","), null != e3.id && (t3 += e3.id), null != e3.data && (t3 += JSON.stringify(e3.data, this.replacer)), t3;
      }
      encodeAsBinary(e3) {
        const t3 = be(e3), s2 = this.encodeAsString(t3.packet), n2 = t3.buffers;
        return n2.unshift(s2), n2;
      }
    }, Decoder: Te });
    function Pe(e3, t3, s2) {
      return e3.on(t3, s2), function() {
        e3.off(t3, s2);
      };
    }
    const Se = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 });
    class Oe extends L {
      constructor(e3, t3, s2) {
        super(), this.connected = false, this.recovered = false, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e3, this.nsp = t3, s2 && s2.auth && (this.auth = s2.auth), this._opts = Object.assign({}, s2), this.io._autoConnect && this.open();
      }
      get disconnected() {
        return !this.connected;
      }
      subEvents() {
        if (this.subs)
          return;
        const e3 = this.io;
        this.subs = [Pe(e3, "open", this.onopen.bind(this)), Pe(e3, "packet", this.onpacket.bind(this)), Pe(e3, "error", this.onerror.bind(this)), Pe(e3, "close", this.onclose.bind(this))];
      }
      get active() {
        return !!this.subs;
      }
      connect() {
        return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this;
      }
      open() {
        return this.connect();
      }
      send(...e3) {
        return e3.unshift("message"), this.emit.apply(this, e3), this;
      }
      emit(e3, ...t3) {
        if (Se.hasOwnProperty(e3))
          throw new Error('"' + e3.toString() + '" is a reserved event name');
        if (t3.unshift(e3), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
          return this._addToQueue(t3), this;
        const s2 = { type: ke.EVENT, data: t3, options: {} };
        if (s2.options.compress = false !== this.flags.compress, "function" == typeof t3[t3.length - 1]) {
          const e4 = this.ids++, n3 = t3.pop();
          this._registerAckCallback(e4, n3), s2.id = e4;
        }
        const n2 = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        return this.flags.volatile && (!n2 || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(s2), this.packet(s2)) : this.sendBuffer.push(s2)), this.flags = {}, this;
      }
      _registerAckCallback(e3, t3) {
        var s2;
        const n2 = null !== (s2 = this.flags.timeout) && void 0 !== s2 ? s2 : this._opts.ackTimeout;
        if (void 0 === n2)
          return void (this.acks[e3] = t3);
        const i2 = this.io.setTimeoutFn(() => {
          delete this.acks[e3];
          for (let t4 = 0; t4 < this.sendBuffer.length; t4++)
            this.sendBuffer[t4].id === e3 && this.sendBuffer.splice(t4, 1);
          t3.call(this, new Error("operation has timed out"));
        }, n2);
        this.acks[e3] = (...e4) => {
          this.io.clearTimeoutFn(i2), t3.apply(this, [null, ...e4]);
        };
      }
      emitWithAck(e3, ...t3) {
        const s2 = void 0 !== this.flags.timeout || void 0 !== this._opts.ackTimeout;
        return new Promise((n2, i2) => {
          t3.push((e4, t4) => s2 ? e4 ? i2(e4) : n2(t4) : n2(e4)), this.emit(e3, ...t3);
        });
      }
      _addToQueue(e3) {
        let t3;
        "function" == typeof e3[e3.length - 1] && (t3 = e3.pop());
        const s2 = { id: this._queueSeq++, tryCount: 0, pending: false, args: e3, flags: Object.assign({ fromQueue: true }, this.flags) };
        e3.push((e4, ...n2) => {
          if (s2 === this._queue[0])
            return null !== e4 ? s2.tryCount > this._opts.retries && (this._queue.shift(), t3 && t3(e4)) : (this._queue.shift(), t3 && t3(null, ...n2)), s2.pending = false, this._drainQueue();
        }), this._queue.push(s2), this._drainQueue();
      }
      _drainQueue(e3 = false) {
        if (!this.connected || 0 === this._queue.length)
          return;
        const t3 = this._queue[0];
        t3.pending && !e3 || (t3.pending = true, t3.tryCount++, this.flags = t3.flags, this.emit.apply(this, t3.args));
      }
      packet(e3) {
        e3.nsp = this.nsp, this.io._packet(e3);
      }
      onopen() {
        "function" == typeof this.auth ? this.auth((e3) => {
          this._sendConnectPacket(e3);
        }) : this._sendConnectPacket(this.auth);
      }
      _sendConnectPacket(e3) {
        this.packet({ type: ke.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e3) : e3 });
      }
      onerror(e3) {
        this.connected || this.emitReserved("connect_error", e3);
      }
      onclose(e3, t3) {
        this.connected = false, delete this.id, this.emitReserved("disconnect", e3, t3);
      }
      onpacket(e3) {
        if (e3.nsp === this.nsp)
          switch (e3.type) {
            case ke.CONNECT:
              e3.data && e3.data.sid ? this.onconnect(e3.data.sid, e3.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
              break;
            case ke.EVENT:
            case ke.BINARY_EVENT:
              this.onevent(e3);
              break;
            case ke.ACK:
            case ke.BINARY_ACK:
              this.onack(e3);
              break;
            case ke.DISCONNECT:
              this.ondisconnect();
              break;
            case ke.CONNECT_ERROR:
              this.destroy();
              const t3 = new Error(e3.data.message);
              t3.data = e3.data.data, this.emitReserved("connect_error", t3);
          }
      }
      onevent(e3) {
        const t3 = e3.data || [];
        null != e3.id && t3.push(this.ack(e3.id)), this.connected ? this.emitEvent(t3) : this.receiveBuffer.push(Object.freeze(t3));
      }
      emitEvent(e3) {
        if (this._anyListeners && this._anyListeners.length) {
          const t3 = this._anyListeners.slice();
          for (const s2 of t3)
            s2.apply(this, e3);
        }
        super.emit.apply(this, e3), this._pid && e3.length && "string" == typeof e3[e3.length - 1] && (this._lastOffset = e3[e3.length - 1]);
      }
      ack(e3) {
        const t3 = this;
        let s2 = false;
        return function(...n2) {
          s2 || (s2 = true, t3.packet({ type: ke.ACK, id: e3, data: n2 }));
        };
      }
      onack(e3) {
        const t3 = this.acks[e3.id];
        "function" == typeof t3 && (t3.apply(this, e3.data), delete this.acks[e3.id]);
      }
      onconnect(e3, t3) {
        this.id = e3, this.recovered = t3 && this._pid === t3, this._pid = t3, this.connected = true, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(true);
      }
      emitBuffered() {
        this.receiveBuffer.forEach((e3) => this.emitEvent(e3)), this.receiveBuffer = [], this.sendBuffer.forEach((e3) => {
          this.notifyOutgoingListeners(e3), this.packet(e3);
        }), this.sendBuffer = [];
      }
      ondisconnect() {
        this.destroy(), this.onclose("io server disconnect");
      }
      destroy() {
        this.subs && (this.subs.forEach((e3) => e3()), this.subs = void 0), this.io._destroy(this);
      }
      disconnect() {
        return this.connected && this.packet({ type: ke.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
      }
      close() {
        return this.disconnect();
      }
      compress(e3) {
        return this.flags.compress = e3, this;
      }
      get volatile() {
        return this.flags.volatile = true, this;
      }
      timeout(e3) {
        return this.flags.timeout = e3, this;
      }
      onAny(e3) {
        return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e3), this;
      }
      prependAny(e3) {
        return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e3), this;
      }
      offAny(e3) {
        if (!this._anyListeners)
          return this;
        if (e3) {
          const t3 = this._anyListeners;
          for (let s2 = 0; s2 < t3.length; s2++)
            if (e3 === t3[s2])
              return t3.splice(s2, 1), this;
        } else
          this._anyListeners = [];
        return this;
      }
      listenersAny() {
        return this._anyListeners || [];
      }
      onAnyOutgoing(e3) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e3), this;
      }
      prependAnyOutgoing(e3) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e3), this;
      }
      offAnyOutgoing(e3) {
        if (!this._anyOutgoingListeners)
          return this;
        if (e3) {
          const t3 = this._anyOutgoingListeners;
          for (let s2 = 0; s2 < t3.length; s2++)
            if (e3 === t3[s2])
              return t3.splice(s2, 1), this;
        } else
          this._anyOutgoingListeners = [];
        return this;
      }
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      notifyOutgoingListeners(e3) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const t3 = this._anyOutgoingListeners.slice();
          for (const s2 of t3)
            s2.apply(this, e3.data);
        }
      }
    }
    function Ce(e3) {
      e3 = e3 || {}, this.ms = e3.min || 100, this.max = e3.max || 1e4, this.factor = e3.factor || 2, this.jitter = e3.jitter > 0 && e3.jitter <= 1 ? e3.jitter : 0, this.attempts = 0;
    }
    Ce.prototype.duration = function() {
      var e3 = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var t3 = Math.random(), s2 = Math.floor(t3 * this.jitter * e3);
        e3 = 1 & Math.floor(10 * t3) ? e3 + s2 : e3 - s2;
      }
      return 0 | Math.min(e3, this.max);
    }, Ce.prototype.reset = function() {
      this.attempts = 0;
    }, Ce.prototype.setMin = function(e3) {
      this.ms = e3;
    }, Ce.prototype.setMax = function(e3) {
      this.max = e3;
    }, Ce.prototype.setJitter = function(e3) {
      this.jitter = e3;
    };
    class De extends L {
      constructor(e3, t3) {
        var s2;
        super(), this.nsps = {}, this.subs = [], e3 && "object" == typeof e3 && (t3 = e3, e3 = void 0), (t3 = t3 || {}).path = t3.path || "/socket.io", this.opts = t3, q(this, t3), this.reconnection(false !== t3.reconnection), this.reconnectionAttempts(t3.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t3.reconnectionDelay || 1e3), this.reconnectionDelayMax(t3.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (s2 = t3.randomizationFactor) && void 0 !== s2 ? s2 : 0.5), this.backoff = new Ce({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(null == t3.timeout ? 2e4 : t3.timeout), this._readyState = "closed", this.uri = e3;
        const n2 = t3.parser || Ee;
        this.encoder = new n2.Encoder(), this.decoder = new n2.Decoder(), this._autoConnect = false !== t3.autoConnect, this._autoConnect && this.open();
      }
      reconnection(e3) {
        return arguments.length ? (this._reconnection = !!e3, this) : this._reconnection;
      }
      reconnectionAttempts(e3) {
        return void 0 === e3 ? this._reconnectionAttempts : (this._reconnectionAttempts = e3, this);
      }
      reconnectionDelay(e3) {
        var t3;
        return void 0 === e3 ? this._reconnectionDelay : (this._reconnectionDelay = e3, null === (t3 = this.backoff) || void 0 === t3 || t3.setMin(e3), this);
      }
      randomizationFactor(e3) {
        var t3;
        return void 0 === e3 ? this._randomizationFactor : (this._randomizationFactor = e3, null === (t3 = this.backoff) || void 0 === t3 || t3.setJitter(e3), this);
      }
      reconnectionDelayMax(e3) {
        var t3;
        return void 0 === e3 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e3, null === (t3 = this.backoff) || void 0 === t3 || t3.setMax(e3), this);
      }
      timeout(e3) {
        return arguments.length ? (this._timeout = e3, this) : this._timeout;
      }
      maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
      }
      open(e3) {
        if (~this._readyState.indexOf("open"))
          return this;
        this.engine = new he(this.uri, this.opts);
        const t3 = this.engine, s2 = this;
        this._readyState = "opening", this.skipReconnect = false;
        const n2 = Pe(t3, "open", function() {
          s2.onopen(), e3 && e3();
        }), i2 = (t4) => {
          this.cleanup(), this._readyState = "closed", this.emitReserved("error", t4), e3 ? e3(t4) : this.maybeReconnectOnOpen();
        }, r2 = Pe(t3, "error", i2);
        if (false !== this._timeout) {
          const e4 = this._timeout, s3 = this.setTimeoutFn(() => {
            n2(), i2(new Error("timeout")), t3.close();
          }, e4);
          this.opts.autoUnref && s3.unref(), this.subs.push(() => {
            this.clearTimeoutFn(s3);
          });
        }
        return this.subs.push(n2), this.subs.push(r2), this;
      }
      connect(e3) {
        return this.open(e3);
      }
      onopen() {
        this.cleanup(), this._readyState = "open", this.emitReserved("open");
        const e3 = this.engine;
        this.subs.push(Pe(e3, "ping", this.onping.bind(this)), Pe(e3, "data", this.ondata.bind(this)), Pe(e3, "error", this.onerror.bind(this)), Pe(e3, "close", this.onclose.bind(this)), Pe(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      onping() {
        this.emitReserved("ping");
      }
      ondata(e3) {
        try {
          this.decoder.add(e3);
        } catch (e4) {
          this.onclose("parse error", e4);
        }
      }
      ondecoded(e3) {
        ne(() => {
          this.emitReserved("packet", e3);
        }, this.setTimeoutFn);
      }
      onerror(e3) {
        this.emitReserved("error", e3);
      }
      socket(e3, t3) {
        let s2 = this.nsps[e3];
        return s2 ? this._autoConnect && !s2.active && s2.connect() : (s2 = new Oe(this, e3, t3), this.nsps[e3] = s2), s2;
      }
      _destroy(e3) {
        const t3 = Object.keys(this.nsps);
        for (const e4 of t3)
          if (this.nsps[e4].active)
            return;
        this._close();
      }
      _packet(e3) {
        const t3 = this.encoder.encode(e3);
        for (let s2 = 0; s2 < t3.length; s2++)
          this.engine.write(t3[s2], e3.options);
      }
      cleanup() {
        this.subs.forEach((e3) => e3()), this.subs.length = 0, this.decoder.destroy();
      }
      _close() {
        this.skipReconnect = true, this._reconnecting = false, this.onclose("forced close"), this.engine && this.engine.close();
      }
      disconnect() {
        return this._close();
      }
      onclose(e3, t3) {
        this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e3, t3), this._reconnection && !this.skipReconnect && this.reconnect();
      }
      reconnect() {
        if (this._reconnecting || this.skipReconnect)
          return this;
        const e3 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
          this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = false;
        else {
          const t3 = this.backoff.duration();
          this._reconnecting = true;
          const s2 = this.setTimeoutFn(() => {
            e3.skipReconnect || (this.emitReserved("reconnect_attempt", e3.backoff.attempts), e3.skipReconnect || e3.open((t4) => {
              t4 ? (e3._reconnecting = false, e3.reconnect(), this.emitReserved("reconnect_error", t4)) : e3.onreconnect();
            }));
          }, t3);
          this.opts.autoUnref && s2.unref(), this.subs.push(() => {
            this.clearTimeoutFn(s2);
          });
        }
      }
      onreconnect() {
        const e3 = this.backoff.attempts;
        this._reconnecting = false, this.backoff.reset(), this.emitReserved("reconnect", e3);
      }
    }
    const Me = {};
    function Le(e3, t3) {
      "object" == typeof e3 && (t3 = e3, e3 = void 0);
      const s2 = function(e4, t4 = "", s3) {
        let n3 = e4;
        s3 = s3 || "undefined" != typeof location && location, null == e4 && (e4 = s3.protocol + "//" + s3.host), "string" == typeof e4 && ("/" === e4.charAt(0) && (e4 = "/" === e4.charAt(1) ? s3.protocol + e4 : s3.host + e4), /^(https?|wss?):\/\//.test(e4) || (e4 = void 0 !== s3 ? s3.protocol + "//" + e4 : "https://" + e4), n3 = le(e4)), n3.port || (/^(http|ws)$/.test(n3.protocol) ? n3.port = "80" : /^(http|ws)s$/.test(n3.protocol) && (n3.port = "443")), n3.path = n3.path || "/";
        const i3 = -1 !== n3.host.indexOf(":") ? "[" + n3.host + "]" : n3.host;
        return n3.id = n3.protocol + "://" + i3 + ":" + n3.port + t4, n3.href = n3.protocol + "://" + i3 + (s3 && s3.port === n3.port ? "" : ":" + n3.port), n3;
      }(e3, (t3 = t3 || {}).path || "/socket.io"), n2 = s2.source, i2 = s2.id, r2 = s2.path, o2 = Me[i2] && r2 in Me[i2].nsps;
      let a2;
      return t3.forceNew || t3["force new connection"] || false === t3.multiplex || o2 ? a2 = new De(n2, t3) : (Me[i2] || (Me[i2] = new De(n2, t3)), a2 = Me[i2]), s2.query && !t3.query && (t3.query = s2.queryKey), a2.socket(s2.path, t3);
    }
    Object.assign(Le, { Manager: De, Socket: Oe, io: Le, connect: Le });
    const Re = function(...e3) {
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        const i2 = n("/df", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2), i2.send();
      });
    }, Ue = 47;
    function Be(e3) {
      return e3 === Ue;
    }
    function Ne(e3, t3, s2, n2) {
      let i2 = "", r2 = 0, o2 = -1, a2 = 0, c2 = 0;
      for (let l2 = 0; l2 <= e3.length; ++l2) {
        if (l2 < e3.length)
          c2 = e3.charCodeAt(l2);
        else {
          if (n2(c2))
            break;
          c2 = Ue;
        }
        if (n2(c2)) {
          if (o2 === l2 - 1 || 1 === a2)
            ;
          else if (2 === a2) {
            if (i2.length < 2 || 2 !== r2 || 46 !== i2.charCodeAt(i2.length - 1) || 46 !== i2.charCodeAt(i2.length - 2)) {
              if (i2.length > 2) {
                const e4 = i2.lastIndexOf(s2);
                -1 === e4 ? (i2 = "", r2 = 0) : (i2 = i2.slice(0, e4), r2 = i2.length - 1 - i2.lastIndexOf(i2, s2)), o2 = l2, a2 = 0;
                continue;
              }
              if (0 !== i2.length) {
                i2 = "", r2 = 0, o2 = l2, a2 = 0;
                continue;
              }
            }
            t3 && (i2 += i2.length > 0 ? `${s2}..` : "..", r2 = 2);
          } else
            i2.length > 0 ? i2 += `${s2}${e3.slice(o2 + 1, l2)}` : i2 = e3.slice(o2 + 1, l2), r2 = l2 - o2 - 1;
          o2 = l2, a2 = 0;
        } else
          46 === c2 && -1 !== a2 ? ++a2 : a2 = -1;
      }
      return i2;
    }
    const qe = { resolve(...e3) {
      let t3 = "", s2 = false;
      for (let n2 = e3.length - 1; n2 >= -1 && !s2; n2--) {
        const i2 = n2 >= 0 ? e3[n2] : "/";
        0 !== i2.length && (t3 = `${i2}/${t3}`, s2 = i2.charCodeAt(0) === Ue);
      }
      return t3 = Ne(t3, !s2, "/", Be), s2 ? `/${t3}` : t3.length > 0 ? t3 : ".";
    }, normalize(e3) {
      if (0 === e3.length)
        return ".";
      const t3 = e3.charCodeAt(0) === Ue, s2 = e3.charCodeAt(e3.length - 1) === Ue;
      return 0 === (e3 = Ne(e3, !t3, "/", Be)).length ? t3 ? "/" : s2 ? "./" : "." : (s2 && (e3 += "/"), t3 ? `/${e3}` : e3);
    }, isAbsolute: (e3) => e3.length > 0 && e3.charCodeAt(0) === Ue, join(...e3) {
      if (0 === e3.length)
        return ".";
      let t3;
      for (let s2 = 0; s2 < e3.length; ++s2) {
        const n2 = e3[s2];
        n2.length > 0 && (void 0 === t3 ? t3 = n2 : t3 += `/${n2}`);
      }
      return void 0 === t3 ? "." : qe.normalize(t3);
    }, relative(e3, t3) {
      if (e3 === t3)
        return "";
      if ((e3 = qe.resolve(e3)) === (t3 = qe.resolve(t3)))
        return "";
      const s2 = e3.length, n2 = s2 - 1, i2 = t3.length - 1, r2 = n2 < i2 ? n2 : i2;
      let o2 = -1, a2 = 0;
      for (; a2 < r2; a2++) {
        const s3 = e3.charCodeAt(1 + a2);
        if (s3 !== t3.charCodeAt(1 + a2))
          break;
        s3 === Ue && (o2 = a2);
      }
      if (a2 === r2)
        if (i2 > r2) {
          if (t3.charCodeAt(1 + a2) === Ue)
            return t3.slice(1 + a2 + 1);
          if (0 === a2)
            return t3.slice(1 + a2);
        } else
          n2 > r2 && (e3.charCodeAt(1 + a2) === Ue ? o2 = a2 : 0 === a2 && (o2 = 0));
      let c2 = "";
      for (a2 = 1 + o2 + 1; a2 <= s2; ++a2)
        a2 !== s2 && e3.charCodeAt(a2) !== Ue || (c2 += 0 === c2.length ? ".." : "/..");
      return `${c2}${t3.slice(1 + o2)}`;
    }, toNamespacedPath: (e3) => e3, dirname(e3) {
      if (0 === e3.length)
        return ".";
      const t3 = e3.charCodeAt(0) === Ue;
      let s2 = -1, n2 = true;
      for (let t4 = e3.length - 1; t4 >= 1; --t4)
        if (e3.charCodeAt(t4) === Ue) {
          if (!n2) {
            s2 = t4;
            break;
          }
        } else
          n2 = false;
      return -1 === s2 ? t3 ? "/" : "." : t3 && 1 === s2 ? "//" : e3.slice(0, s2);
    }, basename(e3, t3) {
      let s2 = 0, n2 = -1, i2 = true;
      if (void 0 !== t3 && t3.length > 0 && t3.length <= e3.length) {
        if (t3 === e3)
          return "";
        let r2 = t3.length - 1, o2 = -1;
        for (let a2 = e3.length - 1; a2 >= 0; --a2) {
          const c2 = e3.charCodeAt(a2);
          if (c2 === Ue) {
            if (!i2) {
              s2 = a2 + 1;
              break;
            }
          } else
            -1 === o2 && (i2 = false, o2 = a2 + 1), r2 >= 0 && (c2 === t3.charCodeAt(r2) ? -1 == --r2 && (n2 = a2) : (r2 = -1, n2 = o2));
        }
        return s2 === n2 ? n2 = o2 : -1 === n2 && (n2 = e3.length), e3.slice(s2, n2);
      }
      for (let t4 = e3.length - 1; t4 >= 0; --t4)
        if (e3.charCodeAt(t4) === Ue) {
          if (!i2) {
            s2 = t4 + 1;
            break;
          }
        } else
          -1 === n2 && (i2 = false, n2 = t4 + 1);
      return -1 === n2 ? "" : e3.slice(s2, n2);
    }, extname(e3) {
      let t3 = -1, s2 = 0, n2 = -1, i2 = true, r2 = 0;
      for (let o2 = e3.length - 1; o2 >= 0; --o2) {
        const a2 = e3.charCodeAt(o2);
        if (a2 !== Ue)
          -1 === n2 && (i2 = false, n2 = o2 + 1), 46 === a2 ? -1 === t3 ? t3 = o2 : 1 !== r2 && (r2 = 1) : -1 !== t3 && (r2 = -1);
        else if (!i2) {
          s2 = o2 + 1;
          break;
        }
      }
      return -1 === t3 || -1 === n2 || 0 === r2 || 1 === r2 && t3 === n2 - 1 && t3 === s2 + 1 ? "" : e3.slice(t3, n2);
    }, format: function(e3, t3) {
      validateObject(t3, "pathObject");
      const s2 = t3.dir || t3.root, n2 = t3.base || `${t3.name || ""}${t3.ext || ""}`;
      return s2 ? s2 === t3.root ? `${s2}${n2}` : `${s2}${e3}${n2}` : n2;
    }.bind(null, "/"), parse(e3) {
      const t3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === e3.length)
        return t3;
      const s2 = e3.charCodeAt(0) === Ue;
      let n2;
      s2 ? (t3.root = "/", n2 = 1) : n2 = 0;
      let i2 = -1, r2 = 0, o2 = -1, a2 = true, c2 = e3.length - 1, l2 = 0;
      for (; c2 >= n2; --c2) {
        const t4 = e3.charCodeAt(c2);
        if (t4 !== Ue)
          -1 === o2 && (a2 = false, o2 = c2 + 1), 46 === t4 ? -1 === i2 ? i2 = c2 : 1 !== l2 && (l2 = 1) : -1 !== i2 && (l2 = -1);
        else if (!a2) {
          r2 = c2 + 1;
          break;
        }
      }
      if (-1 !== o2) {
        const n3 = 0 === r2 && s2 ? 1 : r2;
        -1 === i2 || 0 === l2 || 1 === l2 && i2 === o2 - 1 && i2 === r2 + 1 ? t3.base = t3.name = e3.slice(n3, o2) : (t3.name = e3.slice(n3, i2), t3.base = e3.slice(n3, o2), t3.ext = e3.slice(i2, o2));
      }
      return r2 > 0 ? t3.dir = e3.slice(0, r2 - 1) : s2 && (t3.dir = "/"), t3;
    }, sep: "/", delimiter: ":", win32: null, posix: null }, Fe = qe, je = (e3) => ("gui" === puter.env || (e3 || (e3 = "."), e3 && (e3.startsWith("/") || e3.startsWith("~") || !puter.appID) || (e3 = Fe.join("~/AppData", puter.appID, e3))), e3), ze = function(...e3) {
      let t3 = {};
      return "string" == typeof e3[0] && "object" == typeof e3[1] && !(e3[1] instanceof Function) || "object" == typeof e3[0] && null !== e3[0] ? "string" == typeof e3[0] ? (t3.path = e3[0], Object.assign(t3, e3[1]), t3.success = e3[2], t3.error = e3[3]) : t3 = e3[0] : "string" == typeof e3[0] && (t3.path = e3[0], t3.success = e3[1], t3.error = e3[2]), new Promise(async (e4, s2) => {
        var _a3, _b3, _c2;
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        const i2 = n("/mkdir", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2), t3.path = je(t3.path), i2.send(JSON.stringify({ parent: Fe.dirname(t3.path), path: Fe.basename(t3.path), overwrite: (_a3 = t3.overwrite) != null ? _a3 : false, dedupe_name: (_b3 = t3.rename || t3.dedupeName) != null ? _b3 : false, shortcut_to: t3.shortcutTo, original_client_socket_id: this.socket.id, create_missing_parents: (_c2 = t3.recursive || t3.createMissingParents) != null ? _c2 : false }));
      });
    }, We = function(...e3) {
      var _a3, _b3, _c2, _d2, _e4, _f2, _g2, _h2, _i2;
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { source: e3[0], destination: e3[1], overwrite: (_a3 = e3[2]) == null ? void 0 : _a3.overwrite, new_name: ((_b3 = e3[2]) == null ? void 0 : _b3.newName) || ((_c2 = e3[2]) == null ? void 0 : _c2.new_name), create_missing_parents: ((_d2 = e3[2]) == null ? void 0 : _d2.createMissingParents) || ((_e4 = e3[2]) == null ? void 0 : _e4.create_missing_parents), new_metadata: ((_f2 = e3[2]) == null ? void 0 : _f2.newMetadata) || ((_g2 = e3[2]) == null ? void 0 : _g2.new_metadata), original_client_socket_id: ((_h2 = e3[2]) == null ? void 0 : _h2.excludeSocketID) || ((_i2 = e3[2]) == null ? void 0 : _i2.original_client_socket_id), success: e3[3], error: e3[4] }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        t3.source = je(t3.source), t3.destination = je(t3.destination);
        const i2 = n("/copy", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2), i2.send(JSON.stringify({ original_client_socket_id: this.socket.id, socket_id: this.socket.id, source: t3.source, destination: t3.destination, overwrite: t3.overwrite, new_name: t3.new_name || t3.newName, dedupe_name: t3.dedupe_name || t3.dedupeName }));
      });
    }, Xe = function(...e3) {
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { path: e3[0], new_name: e3[1], success: e3[2], error: e3[3] }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        const i2 = n("/rename", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2);
        let o2 = { original_client_socket_id: t3.excludeSocketID || t3.original_client_socket_id, new_name: t3.new_name || t3.newName };
        void 0 !== t3.uid ? o2.uid = t3.uid : void 0 !== t3.path && (o2.path = je(t3.path)), i2.send(JSON.stringify(o2));
      });
    }, Ve = async function(s2, n2, i2 = {}) {
      return new Promise(async (r2, o2) => {
        var _a3, _b3, _c2, _d2, _e4, _f2, _g2;
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e3) {
            o2(e3);
          }
        const a2 = (e3) => (i2.error && "function" == typeof i2.error && i2.error(e3), o2(e3));
        let c2 = new XMLHttpRequest();
        if ("/" === n2)
          return a2("Can not upload to root directory.");
        n2 = je(n2);
        const l2 = t2();
        i2.init && "function" == typeof i2.init && i2.init(l2, c2);
        let h2, u2 = 0, d2 = 0, p2 = 0, f2 = false;
        if (Array.isArray(s2) && s2.length > 0)
          for (let e3 = 0; e3 < s2.length; e3++)
            (s2[e3] instanceof DataTransferItem || s2[e3] instanceof DataTransferItemList) && (f2 = true);
        if (s2 instanceof DataTransferItemList || s2 instanceof DataTransferItem || s2[0] instanceof DataTransferItem || i2.parsedDataTransferItems)
          h2 = i2.parsedDataTransferItems ? s2 : await puter.ui.getEntriesFromDataTransferItems(s2), h2.sort((e3, t3) => e3.isDirectory && !t3.isDirectory ? -1 : !e3.isDirectory && t3.isDirectory ? 1 : e3.isDirectory && t3.isDirectory ? 0 : e3.size - t3.size);
        else if (s2 instanceof File || s2[0] instanceof File || s2 instanceof FileList || s2[0] instanceof FileList) {
          h2 = Array.isArray(s2) ? s2 : s2 instanceof FileList ? Array.from(s2) : [s2], h2.sort((e3, t3) => e3.size - t3.size);
          for (let e3 = 0; e3 < h2.length; e3++)
            h2[e3].filepath = h2[e3].name, h2[e3].fullPath = h2[e3].name;
        } else if (s2 instanceof Blob) {
          h2 = [new File([s2], i2.name, { type: "application/octet-stream" })];
          for (let e3 = 0; e3 < h2.length; e3++)
            h2[e3].filepath = h2[e3].name, h2[e3].fullPath = h2[e3].name;
        } else {
          if ("string" != typeof s2)
            return a2({ code: "field_invalid", message: "upload() items parameter is an invalid type" });
          h2 = [new File([s2], "default.txt", { type: "text/plain" })];
          for (let e3 = 0; e3 < h2.length; e3++)
            h2[e3].filepath = h2[e3].name, h2[e3].fullPath = h2[e3].name;
        }
        let g2, m2 = [], y2 = {}, b2 = [];
        for (let e3 = 0; e3 < h2.length; e3++)
          if (h2[e3]) {
            if (h2[e3].isDirectory)
              m2.push({ path: Fe.join(n2, h2[e3].finalPath ? h2[e3].finalPath : h2[e3].fullPath) });
            else {
              let t3 = h2[e3].finalPath ? h2[e3].finalPath : h2[e3].fullPath, [s3, r3] = [t3 == null ? void 0 : t3.slice(0, t3 == null ? void 0 : t3.lastIndexOf("/")), t3 == null ? void 0 : t3.slice((t3 == null ? void 0 : t3.lastIndexOf("/")) + 1)];
              if ("" != r3 && b2.push(h2[e3]), i2.createFileParent && t3.includes("/")) {
                let e4;
                s3.split("/").forEach((t4) => {
                  e4 = e4 ? e4 + "/" + t4 : t4;
                  let s4 = Fe.join(n2, e4);
                  y2[s4] || (y2[s4] = true, m2.push({ path: s4 }));
                });
              }
            }
            void 0 !== h2[e3].size && (p2 += h2[e3].size);
          }
        if (0 === m2.length && 0 === b2.length)
          return a2({ code: "EMPTY_UPLOAD", message: "No files or directories to upload." });
        if ("web" !== puter.env)
          try {
            if (g2 = await this.space(), g2.capacity - g2.used < p2)
              return a2({ code: "NOT_ENOUGH_SPACE", message: "Not enough storage space available." });
          } catch (e3) {
          }
        p2 *= 2;
        const w2 = new FormData();
        m2.sort((e3, t3) => t3.path.length - e3.path.length);
        let v2 = [];
        for (let e3 = 0; e3 < m2.length; e3++) {
          for (let t3 = 0; t3 < b2.length; t3++)
            !b2[t3].puter_path_param && Fe.join(n2, b2[t3].filepath).startsWith(m2[e3].path + "/") && (b2[t3].puter_path_param = `$dir_${e3}/` + Fe.basename(b2[t3].filepath));
          for (let t3 = 0; t3 < m2.length; t3++)
            !m2[t3].puter_path_param && m2[t3].path.startsWith(m2[e3].path + "/") && (m2[t3].puter_path_param = `$dir_${e3}/` + Fe.basename(m2[t3].path));
        }
        for (let e3 = 0; e3 < m2.length; e3++) {
          let t3 = Fe.dirname(m2[e3].puter_path_param || m2[e3].path), s3 = m2[e3].puter_path_param || m2[e3].path;
          "/" !== t3 && (s3 = s3.replace(t3, "")), v2.push({ op: "mkdir", parent: t3, path: s3, overwrite: (_a3 = i2.overwrite) != null ? _a3 : false, dedupe_name: (_b3 = i2.dedupeName) != null ? _b3 : true, create_missing_ancestors: (_c2 = i2.createMissingAncestors) != null ? _c2 : true, as: `dir_${e3}` });
        }
        v2.reverse(), w2.append("operation_id", l2), w2.append("socket_id", this.socket.id), w2.append("original_client_socket_id", this.socket.id);
        for (let e3 = 0; e3 < v2.length; e3++)
          w2.append("operation", JSON.stringify(v2[e3]));
        if (!i2.shortcutTo)
          for (let e3 = 0; e3 < b2.length; e3++)
            w2.append("fileinfo", JSON.stringify({ name: b2[e3].name, type: b2[e3].type, size: b2[e3].size }));
        for (let e3 = 0; e3 < b2.length; e3++)
          w2.append("operation", JSON.stringify({ op: i2.shortcutTo ? "shortcut" : "write", dedupe_name: (_d2 = i2.dedupeName) != null ? _d2 : true, overwrite: (_e4 = i2.overwrite) != null ? _e4 : false, create_missing_ancestors: i2.createMissingAncestors || i2.createMissingParents, operation_id: l2, path: b2[e3].puter_path_param && Fe.dirname((_f2 = b2[e3].puter_path_param) != null ? _f2 : "") || b2[e3].filepath && Fe.join(n2, Fe.dirname(b2[e3].filepath)) || "", name: Fe.basename(b2[e3].filepath), item_upload_id: e3, shortcut_to: i2.shortcutTo, shortcut_to_uid: i2.shortcutTo, app_uid: i2.appUID }));
        if (!i2.shortcutTo)
          for (let e3 = 0; e3 < b2.length; e3++)
            w2.append("file", (_g2 = b2[e3]) != null ? _g2 : "");
        const _2 = (e3) => {
          e3.operation_id === l2 && (d2 += e3.loaded_diff);
        };
        this.socket.on("upload.progress", _2);
        let A2 = null;
        c2.open("post", this.APIOrigin + "/batch", true), c2.setRequestHeader("Authorization", "Bearer " + this.authToken), c2.upload.addEventListener("progress", function(e3) {
          let t3;
          null === A2 ? (t3 = e3.loaded, A2 = 0) : t3 = e3.loaded - A2, A2 += t3, u2 += t3;
          let s3 = ((d2 + u2) / p2 * 100).toFixed(2);
          s3 = s3 > 100 ? 100 : s3, i2.progress && "function" == typeof i2.progress && i2.progress(l2, s3);
        });
        let k2 = setInterval(function() {
          let e3 = ((d2 + u2) / p2 * 100).toFixed(2);
          e3 = e3 > 100 ? 100 : e3, i2.progress && "function" == typeof i2.progress && i2.progress(l2, e3);
        }, 100);
        c2.onabort = () => {
          clearInterval(k2), this.socket.off("upload.progress", _2), i2.abort && "function" == typeof i2.abort && i2.abort(l2);
        }, c2.onreadystatechange = async (t3) => {
          var _a4;
          if (4 === c2.readyState) {
            const t4 = await e2(c2);
            if (c2.status >= 400 && c2.status < 600 || i2.strict && 218 === c2.status) {
              if (clearInterval(k2), this.socket.off("upload.progress", _2), i2.strict && 218 === c2.status) {
                let e3;
                for (let s3 = 0; s3 < ((_a4 = t4.results) == null ? void 0 : _a4.length); s3++)
                  if (200 !== t4.results[s3].status) {
                    e3 = t4.results[s3];
                    break;
                  }
                return a2(e3);
              }
              return a2(t4);
            }
            {
              t4 && t4.results && 0 !== t4.results.length || puter.debugMode && console.log("no results");
              let e3 = t4.results;
              return e3 = 1 === e3.length ? e3[0] : e3, i2.success && "function" == typeof i2.success && i2.success(e3), clearInterval(k2), this.socket.off("upload.progress", _2), r2(e3);
            }
          }
        }, i2.start && "function" == typeof i2.start && i2.start(), c2.send(w2);
      });
    }, Ge = function(...e3) {
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { path: "string" == typeof e3[0] ? e3[0] : "object" == typeof e3[0] && null !== e3[0] ? e3[0].path : e3[0], success: e3[1], error: e3[2] }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        t3.path = je(t3.path);
        const i2 = n("/read?file=" + encodeURIComponent(t3.path), this.APIOrigin, this.authToken, "get", "application/json;charset=UTF-8", "blob");
        r(i2, t3.success, t3.error, e4, s2), i2.send();
      });
    }, Ke = async function(...e3) {
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { path: e3[0], options: "object" == typeof e3[1] ? e3[1] : {}, success: "object" == typeof e3[1] ? e3[2] : e3[1], error: "object" == typeof e3[1] ? e3[3] : e3[2] }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        const i2 = n("/stat", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2);
        let o2 = {};
        void 0 !== t3.uid ? o2.uid = t3.uid : void 0 !== t3.path && (o2.path = je(t3.path)), o2.return_subdomains = t3.returnSubdomains, o2.return_permissions = t3.returnPermissions, o2.return_versions = t3.returnVersions, o2.return_size = t3.returnSize, i2.send(JSON.stringify(o2));
      });
    }, Ye = function(...e3) {
      var _a3, _b3, _c2, _d2, _e4, _f2, _g2, _h2, _i2;
      let t3;
      return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { source: e3[0], destination: e3[1], overwrite: (_a3 = e3[2]) == null ? void 0 : _a3.overwrite, new_name: ((_b3 = e3[2]) == null ? void 0 : _b3.newName) || ((_c2 = e3[2]) == null ? void 0 : _c2.new_name), create_missing_parents: ((_d2 = e3[2]) == null ? void 0 : _d2.createMissingParents) || ((_e4 = e3[2]) == null ? void 0 : _e4.create_missing_parents), new_metadata: ((_f2 = e3[2]) == null ? void 0 : _f2.newMetadata) || ((_g2 = e3[2]) == null ? void 0 : _g2.new_metadata), original_client_socket_id: ((_h2 = e3[2]) == null ? void 0 : _h2.excludeSocketID) || ((_i2 = e3[2]) == null ? void 0 : _i2.original_client_socket_id) }, new Promise(async (e4, s2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            s2("Authentication failed.");
          }
        if (t3.source = je(t3.source), t3.destination = je(t3.destination), !t3.new_name)
          try {
            if (!(await Ke.bind(this)(t3.destination)).is_dir)
              throw "is not directory";
          } catch (e5) {
            t3.new_name = Fe.basename(t3.destination), t3.destination = Fe.dirname(t3.destination);
          }
        const i2 = n("/move", this.APIOrigin, this.authToken);
        r(i2, t3.success, t3.error, e4, s2), i2.send(JSON.stringify({ source: t3.source, destination: t3.destination, overwrite: t3.overwrite, new_name: t3.new_name || t3.newName, create_missing_parents: t3.create_missing_parents || t3.createMissingParents, new_metadata: t3.new_metadata || t3.newMetadata, original_client_socket_id: t3.excludeSocketID }));
      });
    }, He = async function(e3, t3, s2 = {}) {
      var _a3;
      if (!e3)
        throw new Error({ code: "NO_TARGET_PATH", message: "No target path provided." });
      e3 instanceof File && void 0 === t3 && (e3 = (t3 = e3).name), s2.strict = true, s2.overwrite = (_a3 = s2.overwrite) != null ? _a3 : true, s2.overwrite && void 0 === s2.dedupeName && (s2.dedupeName = false), e3 = je(e3);
      const n2 = Fe.basename(e3), i2 = Fe.dirname(e3);
      if ("string" == typeof t3 ? t3 = new File([t3 != null ? t3 : ""], n2 != null ? n2 : "Untitled.txt", { type: "text/plain" }) : t3 instanceof Blob && (t3 = new File([t3 != null ? t3 : ""], n2 != null ? n2 : "Untitled", { type: t3.type })), t3 || (t3 = new File([t3 != null ? t3 : ""], n2)), !(t3 instanceof File))
        throw new Error({ code: "field_invalid", message: "write() data parameter is an invalid type" });
      return this.upload(t3, i2, s2);
    }, Qe = function(...t3) {
      let s2;
      return s2 = { app_uid: t3[0], items: t3[1], success: t3[2], error: t3[3] }, new Promise(async (t4, r2) => {
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e3) {
            r2("Authentication failed.");
          }
        let o2 = s2.items;
        Array.isArray(o2) || (o2 = [o2]);
        const a2 = n("/sign", this.APIOrigin, this.authToken);
        a2.addEventListener("load", async function(n2) {
          const i2 = await e2(this);
          if (200 !== this.status)
            return s2.error && "function" == typeof s2.error && s2.error(i2), r2(i2);
          {
            let e3, n3 = i2, r3 = n3.token;
            if (1 == o2.length)
              e3 = { ...n3.signatures[0] };
            else {
              let t5 = [];
              for (let e4 = 0; e4 < n3.signatures.length; e4++)
                t5.push({ ...n3.signatures[e4] });
              e3 = t5;
            }
            return s2.success && "function" == typeof s2.success && s2.success({ token: r3, items: e3 }), t4({ token: r3, items: e3 });
          }
        }), a2.upload.addEventListener("progress", function(e3) {
        }), a2.addEventListener("error", function(e3) {
          return i(s2.error, r2, this);
        }), a2.send(JSON.stringify({ app_uid: s2.app_uid, items: o2 }));
      });
    }, Ze = async function(e3, t3) {
      if (!puter.authToken && "web" === puter.env)
        try {
          await puter.ui.authenticateWithPuter();
        } catch (e4) {
          throw "Authentication failed.";
        }
      t3 = je(t3), e3 = je(e3);
      const s2 = Fe.basename(t3), n2 = { op: "symlink", path: Fe.dirname(t3), name: s2, target: e3 }, i2 = new FormData();
      i2.append("operation", JSON.stringify(n2));
      try {
        const e4 = await fetch(this.APIOrigin + "/batch", { method: "POST", headers: { Authorization: `Bearer ${puter.authToken}` }, body: i2 });
        if (200 !== e4.status) {
          const t4 = await e4.text();
          throw console.error("[symlink] fetch error: ", t4), t4;
        }
      } catch (e4) {
        throw console.error("[symlink] fetch error: ", e4), e4;
      }
    }, Je = async function(...e3) {
      var _a3, _b3, _c2, _d2;
      let t3;
      t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { paths: e3[0], recursive: (_b3 = (_a3 = e3[1]) == null ? void 0 : _a3.recursive) != null ? _b3 : true, descendantsOnly: (_d2 = (_c2 = e3[1]) == null ? void 0 : _c2.descendantsOnly) != null ? _d2 : false };
      let s2 = t3.paths;
      return "string" == typeof s2 && (s2 = [s2]), new Promise(async (e4, i2) => {
        var _a4, _b4;
        if (!puter.authToken && "web" === puter.env)
          try {
            await puter.ui.authenticateWithPuter();
          } catch (e5) {
            i2("Authentication failed.");
          }
        const o2 = n("/delete", this.APIOrigin, this.authToken);
        r(o2, t3.success, t3.error, e4, i2), s2 = s2.map((e5) => je(e5)), o2.send(JSON.stringify({ paths: s2, descendants_only: (_a4 = t3.descendants_only || t3.descendantsOnly) != null ? _a4 : false, recursive: (_b4 = t3.recursive) != null ? _b4 : true }));
      });
    };
    var $e = s(294);
    const et = "TFilesystem";
    class tt extends $e.AdvancedBase {
      static PROPERTIES = { delegate: () => {
      } };
      constructor({ delegate: e3 }) {
        super(), this.delegate = e3;
      }
      static IMPLEMENTS = { [et]: { stat: async function(e3) {
        return this.delegate.stat(e3);
      }, readdir: async function(e3) {
        return this.delegate.readdir(e3);
      } } };
    }
    var st = s(717);
    class nt extends $e.AdvancedBase {
      static PROPERTIES = { assocs_path_: () => ({}), assocs_uuid_: () => ({}), entries: () => ({}) };
      get_entry_ei(e3) {
        if (Array.isArray(e3)) {
          for (const t4 of e3) {
            const e4 = this.get_entry_ei(t4);
            if (e4)
              return e4;
          }
          return;
        }
        console.log("GET ENTRY EI", e3);
        const t3 = this.assocs_path_[e3] || this.assocs_uuid_[e3] || e3;
        if (t3)
          return this.entries[t3];
      }
      add_entry({ id: e3 } = {}) {
        const s2 = e3 != null ? e3 : t2(), n2 = { id: s2, stat_has: {}, stat_exp: 0, locks: { stat: new st.RWLock(), members: new st.RWLock() } };
        return this.entries[s2] = n2, n2;
      }
      assoc_path(e3, t3) {
        console.log("ASSOC PATH", e3, t3), this.assocs_path_[e3] = t3;
      }
      assoc_uuid(e3, t3) {
        e3 !== t3 && (this.assocs_uuid_[e3] = t3);
      }
    }
    class it extends tt {
      constructor(e3) {
        super(e3), this.cacheFS = new nt();
      }
      static IMPLEMENTS = { [et]: { stat: async function(e3) {
        var _a3;
        let t3 = this.cacheFS.get_entry_ei((_a3 = e3.path) != null ? _a3 : e3.uid);
        const s2 = ["subdomains", "permissions", "versions", "size"];
        let n2, i2, r2 = {};
        for (const t4 of s2)
          e3["return" + t4.charAt(0).toUpperCase() + t4.slice(1)] && (r2[t4] = true);
        if (t3 && t3.stat && t3.stat_exp > Date.now()) {
          const e4 = await t3.locks.stat.rlock();
          ((e5) => {
            for (const t4 of s2)
              if (r2[t4] && !e5.stat_has[t4])
                return false;
            return true;
          })(t3) && (n2 = t3.stat), e4.unlock();
        }
        if (n2)
          return console.log("CACHE HIT"), n2;
        console.log("CACHE MISS"), t3 && (i2 = await t3.locks.stat.wlock()), console.log("DOING THE STAT", e3);
        const o2 = await this.delegate.stat(e3);
        let a2 = !!t3;
        return t3 = this.cacheFS.get_entry_ei([o2.uid, o2.path]), t3 && (a2 && i2.unlock(), i2 = await t3.locks.stat.wlock()), t3 || (t3 = this.cacheFS.add_entry({ id: o2.uid }), this.cacheFS.assoc_path(o2.path, t3.id), this.cacheFS.assoc_uuid(o2.uid, t3.id), i2 = await t3.locks.stat.wlock()), t3.stat = o2, t3.stat_has = { ...r2 }, t3.stat_exp = Date.now() + 5e3, i2.unlock(), console.log("RETRUNING THE ENTRY", o2), o2;
      }, readdir: async function(e3) {
        let t3 = this.cacheFS.get_entry_ei([e3.path, e3.uid]);
        console.log("CENT", t3, e3);
        let s2, n2 = null;
        if (t3 && t3.members && t3.members_exp > Date.now()) {
          console.log("MEMBERS", t3.members), n2 = [];
          const s3 = await t3.locks.stat.rlock();
          for (const s4 of t3.members) {
            const t4 = this.cacheFS.get_entry_ei(s4);
            if (!t4 || !t4.stat || t4.stat_exp <= Date.now()) {
              console.log("NO MEMBER OR STAT", t4), n2 = null;
              break;
            }
            if (console.log("member", t4), !e3.no_assocs && !t4.stat_has.subdomains) {
              n2 = null;
              break;
            }
            if (!e3.no_assocs && !t4.stat_has.apps) {
              n2 = null;
              break;
            }
            if (!e3.no_thumbs && !t4.stat_has.thumbnail) {
              n2 = null;
              break;
            }
            console.log("PUSHING", t4.stat), n2.push(t4.stat);
          }
          s3.unlock();
        }
        if (console.log("STATS????", n2), n2)
          return n2;
        t3 && (s2 = await t3.locks.members.wlock());
        const i2 = await this.delegate.readdir(e3);
        t3 || (t3 = this.cacheFS.add_entry(e3.uid ? { id: e3.uid } : {}), e3.path && this.cacheFS.assoc_path(e3.path, t3.id), s2 = await t3.locks.members.wlock());
        let r2 = [];
        for (const t4 of i2) {
          let s3 = this.cacheFS.get_entry_ei([t4.path, t4.uid]);
          s3 || (s3 = this.cacheFS.add_entry({ id: t4.uid }), this.cacheFS.assoc_path(t4.path, t4.uid)), r2.push(s3.id), s3.stat = t4, s3.stat_has = { subdomains: !e3.no_assocs, apps: !e3.no_assocs, thumbnail: !e3.no_thumbs }, s3.stat_exp = Date.now() + 3e3;
        }
        t3.members = [];
        for (const e4 of r2)
          t3.members.push(e4);
        return t3.members_exp = Date.now() + 5e3, s2.unlock(), console.log("CACHE ENTRY?", t3), i2;
      } } };
    }
    class rt extends $e.AdvancedBase {
      constructor({ api_info: e3 }) {
        super(), this.api_info = e3;
      }
      static IMPLEMENTS = { [et]: { stat: async function(e3) {
        this.ensure_auth_();
        const t3 = new st.TeePromise(), s2 = new n("/stat", this.api_info.APIOrigin, this.api_info.authToken);
        r(s2, void 0, void 0, t3.resolve.bind(t3), t3.reject.bind(t3));
        let i2 = {};
        return void 0 !== e3.uid ? i2.uid = e3.uid : void 0 !== e3.path && (i2.path = je(e3.path)), i2.return_subdomains = e3.returnSubdomains, i2.return_permissions = e3.returnPermissions, i2.return_versions = e3.returnVersions, i2.return_size = e3.returnSize, s2.send(JSON.stringify(i2)), await t3;
      }, readdir: async function(e3) {
        this.ensure_auth_();
        const t3 = new st.TeePromise(), s2 = new n("/readdir", this.api_info.APIOrigin, this.api_info.authToken);
        return r(s2, void 0, void 0, t3.resolve.bind(t3), t3.reject.bind(t3)), s2.send(JSON.stringify({ path: je(e3.path) })), await t3;
      } } };
      ensure_auth_() {
        if (!this.api_info.authToken && "web" === puter.env)
          try {
            this.ui.authenticateWithPuter();
          } catch (e3) {
            throw new Error("Authentication failed.");
          }
      }
    }
    class ot extends $e.AdvancedBase {
      space = Re;
      mkdir = ze;
      copy = We;
      rename = Xe;
      upload = Ve;
      read = Ge;
      delete = Je;
      move = Ye;
      write = He;
      sign = Qe;
      symlink = Ze;
      static NARI_METHODS = { stat: { positional: ["path"], firstarg_options: true, async fn(e3) {
        return (await this.context.services.aget("filesystem")).filesystem.stat(e3);
      } }, readdir: { positional: ["path"], firstarg_options: true, async fn(e3) {
        return (await this.context.services.aget("filesystem")).filesystem.readdir(e3);
      } } };
      constructor(e3) {
        super(), this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID, this.context = e3, this.initializeSocket();
        const t3 = {};
        Object.defineProperty(t3, "authToken", { get: () => this.authToken }), Object.defineProperty(t3, "APIOrigin", { get: () => this.APIOrigin });
      }
      initializeSocket() {
        this.socket && this.socket.disconnect(), this.socket = Le(this.APIOrigin, { auth: { auth_token: this.authToken } }), this.bindSocketEvents();
      }
      bindSocketEvents() {
        this.socket.on("connect", () => {
          puter.debugMode && console.log("FileSystem Socket: Connected", this.socket.id);
        }), this.socket.on("disconnect", () => {
          puter.debugMode && console.log("FileSystem Socket: Disconnected");
        }), this.socket.on("reconnect", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnected", this.socket.id);
        }), this.socket.on("reconnect_attempt", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Attemps", e3);
        }), this.socket.on("reconnect_error", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Error", e3);
        }), this.socket.on("reconnect_failed", () => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Failed");
        }), this.socket.on("error", (e3) => {
          puter.debugMode && console.error("FileSystem Socket Error:", e3);
        });
      }
      setAuthToken(e3) {
        this.authToken = e3, this.initializeSocket();
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3, this.initializeSocket();
      }
    }
    const at = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      list = c([], "puter-subdomains", void 0, "select");
      create = async (...e3) => {
        let t3 = {};
        return "string" == typeof e3[0] && 1 === e3.length ? (e3[0].match(/^[a-z0-9]+\.puter\.(site|com)$/) && (e3[0] = e3[0].split(".")[0]), t3 = { object: { subdomain: e3[0] } }) : Array.isArray(e3) && 2 === e3.length && "string" == typeof e3[0] ? (e3[0].match(/^[a-z0-9]+\.puter\.(site|com)$/) && (e3[0] = e3[0].split(".")[0]), e3[1] && (e3[1] = je(e3[1])), t3 = { object: { subdomain: e3[0], root_dir: e3[1] } }) : "object" == typeof e3[0] && (t3 = { object: e3[0] }), await c(["object"], "puter-subdomains", void 0, "create").call(this, t3);
      };
      update = async (...e3) => {
        var _a3;
        let t3 = {};
        return Array.isArray(e3) && "string" == typeof e3[0] && (e3[0].match(/^[a-z0-9]+\.puter\.(site|com)$/) && (e3[0] = e3[0].split(".")[0]), e3[1] && (e3[1] = je(e3[1])), t3 = { id: { subdomain: e3[0] }, object: { root_dir: (_a3 = e3[1]) != null ? _a3 : null } }), await c(["object"], "puter-subdomains", void 0, "update").call(this, t3);
      };
      get = async (...e3) => {
        let t3 = {};
        return Array.isArray(e3) && "string" == typeof e3[0] && (e3[0].match(/^[a-z0-9]+\.puter\.(site|com)$/) && (e3[0] = e3[0].split(".")[0]), t3 = { id: { subdomain: e3[0] } }), c(["uid"], "puter-subdomains", void 0, "read").call(this, t3);
      };
      delete = async (...e3) => {
        let t3 = {};
        return Array.isArray(e3) && "string" == typeof e3[0] && (e3[0].match(/^[a-z0-9]+\.puter\.(site|com)$/) && (e3[0] = e3[0].split(".")[0]), t3 = { id: { subdomain: e3[0] } }), c(["uid"], "puter-subdomains", void 0, "delete").call(this, t3);
      };
    }, ct = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      send = async (...e3) => {
        let t3 = {};
        if (!e3 || 0 === e3.length)
          throw { message: "Arguments are required", code: "arguments_required" };
        let s2 = 0;
        "object" == typeof e3[0] ? (t3 = e3[0], s2 = 1) : (t3 = { to: e3[0], subject: e3[1], body: e3[2] }, s2 = 3);
        for (const n2 of e3.slice(s2))
          "object" == typeof n2 && Object.assign(t3, n2);
        return c(["to", "subject", "body"], "puter-send-mail", void 0, "send").call(this, t3);
      };
    }, lt = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      list = async (...e3) => {
        let t3 = {};
        return "object" == typeof e3[0] && null !== e3[0] && (t3.params = e3[0]), t3.predicate = ["user-can-edit"], c(["uid"], "puter-apps", void 0, "select").call(this, t3);
      };
      create = async (...e3) => {
        var _a3, _b3;
        let t3 = {};
        if ("string" == typeof e3[0]) {
          let s2 = e3[1], n2 = (_a3 = e3[2]) != null ? _a3 : e3[0];
          t3 = { object: { name: e3[0], index_url: s2, title: n2 } };
        } else if ("object" == typeof e3[0] && null !== e3[0]) {
          let s2 = e3[0];
          t3 = { object: { name: s2.name, index_url: s2.indexURL, title: s2.title, description: s2.description, icon: s2.icon, maximize_on_start: s2.maximizeOnStart, background: s2.background, filetype_associations: s2.filetypeAssociations, metadata: s2.metadata }, options: { dedupe_name: (_b3 = s2.dedupeName) != null ? _b3 : false } };
        }
        return await c(["object"], "puter-apps", void 0, "create").call(this, t3);
      };
      update = async (...e3) => {
        let t3 = {};
        if (Array.isArray(e3) && "string" == typeof e3[0]) {
          let s2 = e3[1], n2 = { name: s2.name, index_url: s2.indexURL, title: s2.title, description: s2.description, icon: s2.icon, maximize_on_start: s2.maximizeOnStart, background: s2.background, filetype_associations: s2.filetypeAssociations, metadata: s2.metadata };
          t3 = { id: { name: e3[0] }, object: n2 };
        }
        return await c(["object"], "puter-apps", void 0, "update").call(this, t3);
      };
      get = async (...e3) => {
        let t3 = {};
        return Array.isArray(e3) && "string" == typeof e3[0] && ("object" == typeof e3[1] && null !== e3[1] && (t3.params = e3[1]), t3.id = { name: e3[0] }), "object" == typeof e3[0] && null !== e3[0] && (t3.params = e3[0]), c(["uid"], "puter-apps", void 0, "read").call(this, t3);
      };
      delete = async (...e3) => {
        let t3 = {};
        return Array.isArray(e3) && "string" == typeof e3[0] && (t3 = { id: { name: e3[0] } }), c(["uid"], "puter-apps", void 0, "delete").call(this, t3);
      };
      getDeveloperProfile = function(...e3) {
        let t3;
        return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] }, new Promise((t4, s2) => {
          let i2;
          return i2 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] }, new Promise((e4, t5) => {
            const s3 = n("/get-dev-profile", puter.APIOrigin, puter.authToken, "get");
            r(s3, i2.success, i2.error, e4, t5), s3.send();
          });
        });
      };
    }, ht = class {
      constructor(e3) {
        var _a3, _b3, _c2, _d2, _e4, _f2, _g2, _h2, _i2, _j, _k, _l2, _m2, _n2;
        this.readURL = (_a3 = e3.readURL) != null ? _a3 : e3.read_url, this.writeURL = (_b3 = e3.writeURL) != null ? _b3 : e3.write_url, this.metadataURL = (_c2 = e3.metadataURL) != null ? _c2 : e3.metadata_url, this.name = (_d2 = e3.name) != null ? _d2 : e3.fsentry_name, this.uid = (_i2 = (_h2 = (_g2 = (_f2 = (_e4 = e3.uid) != null ? _e4 : e3.uuid) != null ? _f2 : e3.fsentry_uid) != null ? _g2 : e3.fsentry_id) != null ? _h2 : e3.fsentry_uuid) != null ? _i2 : e3.id, this.id = this.uid, this.uuid = this.uid, this.path = (_j = e3.path) != null ? _j : e3.fsentry_path, this.size = (_k = e3.size) != null ? _k : e3.fsentry_size, this.accessed = (_l2 = e3.accessed) != null ? _l2 : e3.fsentry_accessed, this.modified = (_m2 = e3.modified) != null ? _m2 : e3.fsentry_modified, this.created = (_n2 = e3.created) != null ? _n2 : e3.fsentry_created, this.isDirectory = !!(e3.isDirectory || e3.is_dir || e3.fsentry_is_dir);
      }
      write = async function(e3) {
        return puter.fs.write(this.path, new File([e3], this.name), { overwrite: true, dedupeName: false });
      };
      watch = function(e3) {
      };
      open = function(e3) {
      };
      setAsWallpaper = function(e3, t3) {
      };
      rename = function(e3) {
        return puter.fs.rename(this.uid, e3);
      };
      move = function(e3, t3 = false, s2) {
        return puter.fs.move(this.path, e3, t3, s2);
      };
      copy = function(e3, t3 = false, s2 = false) {
        return puter.fs.copy(this.path, e3, t3, s2);
      };
      delete = function() {
        return puter.fs.delete(this.path);
      };
      versions = async function() {
      };
      trash = function() {
      };
      mkdir = async function(e3, t3 = false) {
        if (!this.isDirectory)
          throw new Error("mkdir() can only be called on a directory");
        return puter.fs.mkdir(Fe.join(this.path, e3));
      };
      metadata = async function() {
      };
      readdir = async function() {
        if (!this.isDirectory)
          throw new Error("readdir() can only be called on a directory");
        return puter.fs.readdir(this.path);
      };
      read = async function() {
        return puter.fs.read(this.path);
      };
    };
    class ut extends HTMLElement {
      isUsingFileProtocol = () => "file:" === window.location.protocol;
      constructor(e3, t3) {
        let s2;
        super(), this.attachShadow({ mode: "open" }), this.reject = t3, this.resolve = e3, s2 = `
        <style>
        dialog{
            background: transparent; 
            border: none; 
            box-shadow: none; 
            outline: none;
        }
        .puter-dialog-content {
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 20px;
            background: white;
            box-shadow: 0 0 9px 1px rgb(0 0 0 / 21%);
            padding: 80px 20px;
            -webkit-font-smoothing: antialiased;
            color: #575762;
            position: relative;
            background-image: url('data:image/webp;base64,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');
            background-repeat: no-repeat;
            background-position: center center;
            background-size: 100% 100%;
            background-color: #fff;
        }
        
        dialog * {
            max-width: 500px;
            font-family: "Helvetica Neue", HelveticaNeue, Helvetica, Arial, sans-serif;
        }
        
        dialog p.about{
            text-align: center;
            font-size: 17px;
            padding: 10px 30px;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            color: #404048;
            box-sizing: border-box;
        }
        
        dialog .buttons{
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 20px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .launch-auth-popup-footnote{
            font-size: 11px;
            color: #666;
            margin-top: 10px;
            /* footer at the bottom */
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            text-align: center;
            margin: 0 10px;
        }
        
        dialog .close-btn{
            position: absolute;
            right: 15px;
            top: 10px;
            font-size: 17px;
            color: #8a8a8a;
            cursor: pointer;
        }
        
        dialog .close-btn:hover{
            color: #000;
        }
        
        /* ------------------------------------
        Button
        ------------------------------------*/
        
        dialog .button {
            color: #666666;
            background-color: #eeeeee;
            border-color: #eeeeee;
            font-size: 14px;
            text-decoration: none;
            text-align: center;
            line-height: 40px;
            height: 35px;
            padding: 0 30px;
            margin: 0;
            display: inline-block;
            appearance: none;
            cursor: pointer;
            border: none;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
            border-color: #b9b9b9;
            border-style: solid;
            border-width: 1px;
            line-height: 35px;
            background: -webkit-gradient(linear, left top, left bottom, from(#f6f6f6), to(#e1e1e1));
            background: linear-gradient(#f6f6f6, #e1e1e1);
            -webkit-box-shadow: inset 0px 1px 0px rgb(255 255 255 / 30%), 0 1px 2px rgb(0 0 0 / 15%);
            box-shadow: inset 0px 1px 0px rgb(255 255 255 / 30%), 0 1px 2px rgb(0 0 0 / 15%);
            border-radius: 4px;
            outline: none;
            -webkit-font-smoothing: antialiased;
        }
        
        dialog .button:focus-visible {
            border-color: rgb(118 118 118);
        }
        
        dialog .button:active, dialog .button.active, dialog .button.is-active, dialog .button.has-open-contextmenu {
            text-decoration: none;
            background-color: #eeeeee;
            border-color: #cfcfcf;
            color: #a9a9a9;
            -webkit-transition-duration: 0s;
            transition-duration: 0s;
            -webkit-box-shadow: inset 0 1px 3px rgb(0 0 0 / 20%);
            box-shadow: inset 0px 2px 3px rgb(0 0 0 / 36%), 0px 1px 0px white;
        }
        
        dialog .button.disabled, dialog .button.is-disabled, dialog .button:disabled {
            top: 0 !important;
            background: #EEE !important;
            border: 1px solid #DDD !important;
            text-shadow: 0 1px 1px white !important;
            color: #CCC !important;
            cursor: default !important;
            appearance: none !important;
            pointer-events: none;
        }
        
        dialog .button-action.disabled, dialog .button-action.is-disabled, dialog .button-action:disabled {
            background: #55a975 !important;
            border: 1px solid #60ab7d !important;
            text-shadow: none !important;
            color: #CCC !important;
        }
        
        dialog .button-primary.disabled, dialog .button-primary.is-disabled, dialog .button-primary:disabled {
            background: #8fc2e7 !important;
            border: 1px solid #98adbd !important;
            text-shadow: none !important;
            color: #f5f5f5 !important;
        }
        
        dialog .button-block {
            width: 100%;
        }
        
        dialog .button-primary {
            border-color: #088ef0;
            background: -webkit-gradient(linear, left top, left bottom, from(#34a5f8), to(#088ef0));
            background: linear-gradient(#34a5f8, #088ef0);
            color: white;
        }
        
        dialog .button-danger {
            border-color: #f00808;
            background: -webkit-gradient(linear, left top, left bottom, from(#f83434), to(#f00808));
            background: linear-gradient(#f83434, #f00808);
            color: white;
        }
        
        dialog .button-primary:active, dialog .button-primary.active, dialog .button-primary.is-active, dialog .button-primary-flat:active, dialog .button-primary-flat.active, dialog .button-primary-flat.is-active {
            background-color: #2798eb;
            border-color: #2798eb;
            color: #bedef5;
        }
        
        dialog .button-action {
            border-color: #08bf4e;
            background: -webkit-gradient(linear, left top, left bottom, from(#29d55d), to(#1ccd60));
            background: linear-gradient(#29d55d, #1ccd60);
            color: white;
        }
        
        dialog .button-action:active, dialog .button-action.active, dialog .button-action.is-active, dialog .button-action-flat:active, dialog .button-action-flat.active, dialog .button-action-flat.is-active {
            background-color: #27eb41;
            border-color: #27eb41;
            color: #bef5ca;
        }
        
        dialog .button-giant {
            font-size: 28px;
            height: 70px;
            line-height: 70px;
            padding: 0 70px;
        }
        
        dialog .button-jumbo {
            font-size: 24px;
            height: 60px;
            line-height: 60px;
            padding: 0 60px;
        }
        
        dialog .button-large {
            font-size: 20px;
            height: 50px;
            line-height: 50px;
            padding: 0 50px;
        }
        
        dialog .button-normal {
            font-size: 16px;
            height: 40px;
            line-height: 38px;
            padding: 0 40px;
        }
        
        dialog .button-small {
            height: 30px;
            line-height: 29px;
            padding: 0 30px;
        }
        
        dialog .button-tiny {
            font-size: 9.6px;
            height: 24px;
            line-height: 24px;
            padding: 0 24px;
        }
        
        #launch-auth-popup{
            margin-left: 10px; 
            width: 200px; 
            font-weight: 500; 
            font-size: 15px;
        }
        dialog .button-auth{
            margin-bottom: 10px;
        }
        dialog a, dialog a:visited{
            color: rgb(0 69 238);
            text-decoration: none;
        }
        dialog a:hover{
            text-decoration: underline;
        }
        
        @media (max-width:480px)  { 
            .puter-dialog-content{
                padding: 50px 20px;
            }
            dialog .buttons{
                flex-direction: column-reverse;
            }
            dialog p.about{
                padding: 10px 0;
            }
            dialog .button-auth{
                width: 100% !important;
                margin:0 !important;
                margin-bottom: 10px !important;
            }
        }
        .error-container h1 {
            color: #e74c3c;
            font-size: 20px;
            text-align: center;
        }

        .puter-dialog-content a:focus{
            outline: none;
        }
        </style>`, "file:" === window.location.protocol ? s2 += `<dialog>
                    <div class="puter-dialog-content" style="padding: 20px 40px; background:white !important; font-size: 15px;">
                        <span class="close-btn">&#x2715</span>
                        <div class="error-container">
                            <h1>Puter.js Error: Unsupported Protocol</h1>
                            <p>It looks like you've opened this file directly in your browser (using the <code style="font-family: monospace;">file:///</code> protocol) which is not supported by Puter.js for security reasons.</p>
                            <p>To view this content properly, you need to serve it through a web server. Here are some options:</p>
                            <ul>
                                <li>Use a local development server (e.g., Python's built-in server or Node.js http-server)</li>
                                <li>Upload the files to a web hosting service</li>
                                <li>Use a local server application like XAMPP or MAMP</li>
                            </ul>
                            <p class="help-text">If you're not familiar with these options, consider reaching out to your development team or IT support for assistance.</p>
                        </div>
                        <p style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 10px; text-align: center; font-size:13px;">
                            <a href="https://docs.puter.com" target="_blank">Docs</a><span style="margin:10px; color: #CCC;">|</span>
                            <a href="https://github.com/heyPuter/puter/" target="_blank">Github</a><span style="margin:10px; color: #CCC;">|</span>
                            <a href="https://discord.com/invite/PQcx7Teh8u" target="_blank">Discord</a>
                        </p>
                    </div>
                </dialog>` : s2 += `<dialog>
                <div class="puter-dialog-content">
                    <span class="close-btn">&#x2715</span>
                    <a href="https://puter.com" target="_blank" style="border:none; outline:none; display: block; width: 70px; height: 70px; margin: 0 auto; border-radius: 4px;"><img style="display: block; width: 70px; height: 70px; margin: 0 auto; border-radius: 4px;" src="data:image/png;base64,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"/></a>
                    <p class="about">This website uses Puter to bring you safe, secure, and private AI and Cloud features.</p>
                    <div class="buttons">
                        <button class="button button-auth" id="launch-auth-popup-cancel">Cancel</button>
                        <button class="button button-primary button-auth" id="launch-auth-popup" style="margin-left:10px;">Continue</button>
                    </div>
                    <p style="text-align: center; margin-top: -15px; font-size: 14px;">Powered by <a href="https://docs.puter.com/" target="_blank">Puter.js</a></p>
                    <p class="launch-auth-popup-footnote">By clicking 'Continue' you agree to Puter's <a href="https://puter.com/terms" target="_blank">Terms of Service</a> and <a href="https://puter.com/privacy" target="_blank">Privacy Policy</a>.</p>
                </div>
            </dialog>`, this.shadowRoot.innerHTML = s2, this.messageListener = async (e4) => {
          "puter.token" === e4.data.msg && (this.close(), puter.setAuthToken(e4.data.token), puter.setAppID(e4.data.app_uid), window.removeEventListener("message", this.messageListener), puter.puterAuthState.authGranted = true, this.resolve(), puter.onAuth && "function" == typeof puter.onAuth && puter.getUser().then((e5) => {
            puter.onAuth(e5);
          }), puter.puterAuthState.isPromptOpen = false, puter.puterAuthState.resolver && (puter.puterAuthState.authGranted ? puter.puterAuthState.resolver.resolve() : puter.puterAuthState.resolver.reject(), puter.puterAuthState.resolver = null));
        };
      }
      cancelListener = () => {
        this.close(), window.removeEventListener("message", this.messageListener), puter.puterAuthState.authGranted = false, puter.puterAuthState.isPromptOpen = false, this.reject(new Error("User cancelled the authentication")), puter.puterAuthState.resolver && (puter.puterAuthState.resolver.reject(new Error("User cancelled the authentication")), puter.puterAuthState.resolver = null);
      };
      connectedCallback() {
        var _a3, _b3, _c2;
        (_a3 = this.shadowRoot.querySelector("#launch-auth-popup")) == null ? void 0 : _a3.addEventListener("click", () => {
          var e3 = screen.width / 2 - 300, t3 = screen.height / 2 - 200;
          window.open(puter.defaultGUIOrigin + "/?embedded_in_popup=true&request_auth=true" + (window.crossOriginIsolated ? "&cross_origin_isolated=true" : ""), "Puter", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=600, height=400, top=" + t3 + ", left=" + e3);
        }), window.addEventListener("message", this.messageListener), (_b3 = this.shadowRoot.querySelector("#launch-auth-popup-cancel")) == null ? void 0 : _b3.addEventListener("click", this.cancelListener), (_c2 = this.shadowRoot.querySelector(".close-btn")) == null ? void 0 : _c2.addEventListener("click", this.cancelListener);
      }
      open() {
        this.shadowRoot.querySelector("dialog").showModal();
      }
      close() {
        this.shadowRoot.querySelector("dialog").close();
      }
    }
    customElements.define("puter-dialog", ut);
    const dt = ut;
    class pt {
      constructor(e3) {
        __privateAdd(this, _e2, void 0);
        __privateAdd(this, _t2, void 0);
        __privateSet(this, _e2, e3), __privateSet(this, _t2, (() => {
          const e4 = /* @__PURE__ */ new Map();
          for (let t3 of __privateGet(this, _e2))
            e4[t3] = [];
          return e4;
        })());
      }
      emit(e3, t3) {
        __privateGet(this, _e2).includes(e3) ? __privateGet(this, _t2)[e3].forEach((e4) => {
          e4(t3);
        }) : console.error(`Event name '${e3}' not supported`);
      }
      on(e3, t3) {
        if (__privateGet(this, _e2).includes(e3))
          return __privateGet(this, _t2)[e3].push(t3), this;
        console.error(`Event name '${e3}' not supported`);
      }
      off(e3, t3) {
        if (!__privateGet(this, _e2).includes(e3))
          return void console.error(`Event name '${e3}' not supported`);
        const s2 = __privateGet(this, _t2)[e3], n2 = s2.indexOf(t3);
        return -1 !== n2 && s2.splice(n2, 1), this;
      }
    }
    _e2 = new WeakMap();
    _t2 = new WeakMap();
    const _ft = class extends pt {
      constructor(e3, { target: t3, usesSDK: s2 }) {
        super(["message", "close"]);
        __privateAdd(this, _s, "*");
        __privateAdd(this, _n, void 0);
        __privateAdd(this, _i, void 0);
        this.messageTarget = e3.messageTarget, this.appInstanceID = e3.appInstanceID, this.targetAppInstanceID = t3, __privateSet(this, _n, true), __privateSet(this, _i, s2), this.log = e3.puter.log.fields({ category: "ipc" }), this.log.fields({ cons_source: e3.appInstanceID, source: e3.puter.appInstanceID, target: t3 }).info(`AppConnection created to ${t3}`, this), window.addEventListener("message", (e4) => {
          if ("messageToApp" === e4.data.msg) {
            if (e4.data.appInstanceID !== this.targetAppInstanceID)
              return;
            return e4.data.targetAppInstanceID !== this.appInstanceID ? void console.error(`AppConnection received message intended for wrong app! appInstanceID=${this.appInstanceID}, target=${e4.data.targetAppInstanceID}`) : void this.emit("message", e4.data.contents);
          }
          if ("appClosed" === e4.data.msg) {
            if (e4.data.appInstanceID !== this.targetAppInstanceID)
              return;
            __privateSet(this, _n, false), this.emit("close", { appInstanceID: this.targetAppInstanceID, statusCode: e4.data.statusCode });
          }
        });
      }
      static from(e3, t3) {
        const s2 = new _ft(t3, { target: e3.appInstanceID, usesSDK: e3.usesSDK });
        return s2.response = e3.response, s2;
      }
      get usesSDK() {
        return __privateGet(this, _i);
      }
      postMessage(e3) {
        __privateGet(this, _n) ? __privateGet(this, _i) ? this.messageTarget.postMessage({ msg: "messageToApp", appInstanceID: this.appInstanceID, targetAppInstanceID: this.targetAppInstanceID, targetAppOrigin: "*", contents: e3 }, __privateGet(this, _s)) : console.warn("Trying to post message to a non-SDK app") : console.warn("Trying to post message on a closed AppConnection");
      }
      close() {
        __privateGet(this, _n) ? this.messageTarget.postMessage({ msg: "closeApp", appInstanceID: this.appInstanceID, targetAppInstanceID: this.targetAppInstanceID }, __privateGet(this, _s)) : console.warn("Trying to close an app on a closed AppConnection");
      }
    };
    let ft = _ft;
    _s = new WeakMap();
    _n = new WeakMap();
    _i = new WeakMap();
    const gt = (_a2 = class extends pt {
      constructor(e3, { appInstanceID: t3, parentInstanceID: s2 }) {
        var _a3;
        const n2 = ["localeChanged", "themeChanged", "connection"];
        super(n2);
        __privateAdd(this, _w);
        __privateAdd(this, _r, 1);
        __publicField(this, "itemWatchCallbackFunctions", []);
        __publicField(this, "appInstanceID");
        __publicField(this, "parentInstanceID");
        __privateAdd(this, _o, null);
        __privateAdd(this, _a, []);
        __privateAdd(this, _c, void 0);
        __privateAdd(this, _l, void 0);
        __privateAdd(this, _h, void 0);
        __privateAdd(this, _e3, void 0);
        __privateAdd(this, _u, /* @__PURE__ */ new Map());
        __privateAdd(this, _d, false);
        __privateAdd(this, _p, null);
        __privateAdd(this, _f, function(e3, t3, s2 = {}) {
          var _a3;
          const n2 = __privateWrapper(this, _r)._++;
          (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: e3, env: this.env, appInstanceID: this.appInstanceID, uuid: n2, ...s2 }, "*"), __privateGet(this, _a)[n2] = t3;
        });
        __privateAdd(this, _g, function(e3, t3) {
          var _a3;
          const s2 = this.util.rpc.getDehydrator({ target: this.messageTarget });
          (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: e3, env: this.env, appInstanceID: this.appInstanceID, value: s2.dehydrate(t3) }, "*");
        });
        __privateAdd(this, _m, async function({ callback: e3, method: t3, parameters: s2 }) {
          var _a3;
          let n2, i2;
          await new Promise((e4) => {
            n2 = new Promise((t4) => {
              i2 = t4, e4();
            });
          });
          const r2 = this.util.rpc.registerCallback(i2);
          (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ $: "puter-ipc", v: 2, appInstanceID: this.appInstanceID, env: this.env, msg: t3, parameters: s2, uuid: r2 }, "*");
          const o2 = await n2;
          return e3 && e3(o2), o2;
        });
        __publicField(this, "onWindowClose", function(e3) {
          __privateSet(this, _c, e3);
        });
        __publicField(this, "onItemsOpened", function(e3) {
          if (!__privateGet(this, _l)) {
            let t3 = new URLSearchParams(window.location.search);
            if (t3.has("puter.item.name") && t3.has("puter.item.uid") && t3.has("puter.item.read_url")) {
              let s2 = t3.get("puter.item.path");
              s2.startsWith("~/") || s2.startsWith("/") || (s2 = "~/" + s2), e3([new ht({ name: t3.get("puter.item.name"), path: s2, uid: t3.get("puter.item.uid"), readURL: t3.get("puter.item.read_url"), writeURL: t3.get("puter.item.write_url"), metadataURL: t3.get("puter.item.metadata_url"), size: t3.get("puter.item.size"), accessed: t3.get("puter.item.accessed"), modified: t3.get("puter.item.modified"), created: t3.get("puter.item.created") })]);
            }
          }
          __privateSet(this, _l, e3);
        });
        __publicField(this, "wasLaunchedWithItems", function() {
          const e3 = new URLSearchParams(window.location.search);
          return e3.has("puter.item.name") && e3.has("puter.item.uid") && e3.has("puter.item.read_url");
        });
        __publicField(this, "onLaunchedWithItems", function(e3) {
          if (!__privateGet(this, _h)) {
            let t3 = new URLSearchParams(window.location.search);
            if (t3.has("puter.item.name") && t3.has("puter.item.uid") && t3.has("puter.item.read_url")) {
              let s2 = t3.get("puter.item.path");
              s2.startsWith("~/") || s2.startsWith("/") || (s2 = "~/" + s2), e3([new ht({ name: t3.get("puter.item.name"), path: s2, uid: t3.get("puter.item.uid"), readURL: t3.get("puter.item.read_url"), writeURL: t3.get("puter.item.write_url"), metadataURL: t3.get("puter.item.metadata_url"), size: t3.get("puter.item.size"), accessed: t3.get("puter.item.accessed"), modified: t3.get("puter.item.modified"), created: t3.get("puter.item.created") })]);
            }
          }
          __privateSet(this, _h, e3);
        });
        __publicField(this, "alert", function(e3, t3, s2, n2) {
          return new Promise((n3) => {
            __privateGet(this, _f).call(this, "ALERT", n3, { message: e3, buttons: t3, options: s2 });
          });
        });
        __publicField(this, "socialShare", function(e3, t3, s2, n2) {
          return new Promise((n3) => {
            __privateGet(this, _f).call(this, "socialShare", n3, { url: e3, message: t3, options: s2 });
          });
        });
        __publicField(this, "prompt", function(e3, t3, s2, n2) {
          return new Promise((n3) => {
            __privateGet(this, _f).call(this, "PROMPT", n3, { message: e3, placeholder: t3, options: s2 });
          });
        });
        __publicField(this, "showDirectoryPicker", function(e3, t3) {
          return new Promise((t4) => {
            var _a3;
            const s2 = __privateWrapper(this, _r)._++;
            if ("app" === this.env)
              (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: "showDirectoryPicker", appInstanceID: this.appInstanceID, uuid: s2, options: e3, env: this.env }, "*");
            else {
              let t5 = 700, r2 = 400, o2 = "Puter: Open Directory";
              var n2 = screen.width / 2 - t5 / 2, i2 = screen.height / 2 - r2 / 2;
              window.open(`${puter.defaultGUIOrigin}/action/show-directory-picker?embedded_in_popup=true&msg_id=${s2}&appInstanceID=${this.appInstanceID}&env=${this.env}&options=${JSON.stringify(e3)}`, o2, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + t5 + ", height=" + r2 + ", top=" + i2 + ", left=" + n2);
            }
            __privateGet(this, _a)[s2] = t4;
          });
        });
        __publicField(this, "showOpenFilePicker", function(e3, t3) {
          return new Promise((t4) => {
            var _a3;
            const s2 = __privateWrapper(this, _r)._++;
            if ("app" === this.env)
              (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: "showOpenFilePicker", appInstanceID: this.appInstanceID, uuid: s2, options: e3 != null ? e3 : {}, env: this.env }, "*");
            else {
              let t5 = 700, r2 = 400, o2 = "Puter: Open File";
              var n2 = screen.width / 2 - t5 / 2, i2 = screen.height / 2 - r2 / 2;
              window.open(`${puter.defaultGUIOrigin}/action/show-open-file-picker?embedded_in_popup=true&msg_id=${s2}&appInstanceID=${this.appInstanceID}&env=${this.env}&options=${JSON.stringify(e3 != null ? e3 : {})}`, o2, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + t5 + ", height=" + r2 + ", top=" + i2 + ", left=" + n2);
            }
            __privateGet(this, _a)[s2] = t4;
          });
        });
        __publicField(this, "showFontPicker", function(e3) {
          return new Promise((t3) => {
            __privateGet(this, _f).call(this, "showFontPicker", t3, { options: e3 != null ? e3 : {} });
          });
        });
        __publicField(this, "showColorPicker", function(e3) {
          return new Promise((t3) => {
            __privateGet(this, _f).call(this, "showColorPicker", t3, { options: e3 != null ? e3 : {} });
          });
        });
        __publicField(this, "showSaveFilePicker", function(e3, t3) {
          return new Promise((s2) => {
            var _a3;
            const n2 = __privateWrapper(this, _r)._++, i2 = "[object URL]" === Object.prototype.toString.call(e3) ? e3 : void 0;
            if ("app" === this.env)
              (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: "showSaveFilePicker", appInstanceID: this.appInstanceID, content: i2 ? void 0 : e3, url: i2 ? i2.toString() : void 0, suggestedName: t3 != null ? t3 : "", env: this.env, uuid: n2 }, "*");
            else {
              window.addEventListener("message", async (s4) => {
                var _a4;
                "sendMeFileData" === ((_a4 = s4.data) == null ? void 0 : _a4.msg) && (s4.source.postMessage({ msg: "showSaveFilePickerPopup", content: i2 ? void 0 : e3, url: i2 ? i2.toString() : void 0, suggestedName: t3 != null ? t3 : "", env: this.env, uuid: n2 }, "*"), window.removeEventListener("message", this));
              });
              let s3 = new Blob([e3], { type: "application/octet-stream" }), a2 = URL.createObjectURL(s3), c2 = 700, l2 = 400, h2 = "Puter: Save File";
              var r2 = screen.width / 2 - c2 / 2, o2 = screen.height / 2 - l2 / 2;
              window.open(`${puter.defaultGUIOrigin}/action/show-save-file-picker?embedded_in_popup=true&msg_id=${n2}&appInstanceID=${this.appInstanceID}&env=${this.env}&blobUrl=${encodeURIComponent(a2)}`, h2, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + c2 + ", height=" + l2 + ", top=" + o2 + ", left=" + r2);
            }
            __privateGet(this, _a)[n2] = s2;
          });
        });
        __publicField(this, "setWindowTitle", function(e3, t3, s2) {
          return "function" == typeof t3 ? t3 = void 0 : "object" == typeof t3 && null !== t3 && (t3 = t3.id), new Promise((s3) => {
            __privateGet(this, _f).call(this, "setWindowTitle", s3, { new_title: e3, window_id: t3 });
          });
        });
        __publicField(this, "setWindowWidth", function(e3, t3, s2) {
          return "function" == typeof t3 ? t3 = void 0 : "object" == typeof t3 && null !== t3 && (t3 = t3.id), new Promise((s3) => {
            __privateGet(this, _f).call(this, "setWindowWidth", s3, { width: e3, window_id: t3 });
          });
        });
        __publicField(this, "setWindowHeight", function(e3, t3, s2) {
          return "function" == typeof t3 ? t3 = void 0 : "object" == typeof t3 && null !== t3 && (t3 = t3.id), new Promise((s3) => {
            __privateGet(this, _f).call(this, "setWindowHeight", s3, { height: e3, window_id: t3 });
          });
        });
        __publicField(this, "setWindowSize", function(e3, t3, s2, n2) {
          return "function" == typeof s2 ? s2 = void 0 : "object" == typeof s2 && null !== s2 && (s2 = s2.id), new Promise((n3) => {
            __privateGet(this, _f).call(this, "setWindowSize", n3, { width: e3, height: t3, window_id: s2 });
          });
        });
        __publicField(this, "setWindowPosition", function(e3, t3, s2, n2) {
          return "function" == typeof s2 ? s2 = void 0 : "object" == typeof s2 && null !== s2 && (s2 = s2.id), new Promise((n3) => {
            __privateGet(this, _f).call(this, "setWindowPosition", n3, { x: e3, y: t3, window_id: s2 });
          });
        });
        __publicField(this, "setWindowY", function(e3, t3, s2) {
          return "function" == typeof t3 ? t3 = void 0 : "object" == typeof t3 && null !== t3 && (t3 = t3.id), new Promise((s3) => {
            __privateGet(this, _f).call(this, "setWindowY", s3, { y: e3, window_id: t3 });
          });
        });
        __publicField(this, "setWindowX", function(e3, t3, s2) {
          return "function" == typeof t3 ? t3 = void 0 : "object" == typeof t3 && null !== t3 && (t3 = t3.id), new Promise((s3) => {
            __privateGet(this, _f).call(this, "setWindowX", s3, { x: e3, window_id: t3 });
          });
        });
        __publicField(this, "setMenubar", function(e3) {
          __privateGet(this, _g).call(this, "setMenubar", e3);
        });
        __publicField(this, "requestPermission", function(e3) {
          return new Promise((t3) => {
            if ("app" === this.env)
              return new Promise((t4) => {
                __privateGet(this, _f).call(this, "requestPermission", t4, { options: e3 });
              });
            t3(false);
          });
        });
        __publicField(this, "disableMenuItem", function(e3) {
          __privateGet(this, _g).call(this, "disableMenuItem", { id: e3 });
        });
        __publicField(this, "enableMenuItem", function(e3) {
          __privateGet(this, _g).call(this, "enableMenuItem", { id: e3 });
        });
        __publicField(this, "setMenuItemIcon", function(e3, t3) {
          __privateGet(this, _g).call(this, "setMenuItemIcon", { id: e3, icon: t3 });
        });
        __publicField(this, "setMenuItemIconActive", function(e3, t3) {
          __privateGet(this, _g).call(this, "setMenuItemIconActive", { id: e3, icon: t3 });
        });
        __publicField(this, "setMenuItemChecked", function(e3, t3) {
          __privateGet(this, _g).call(this, "setMenuItemChecked", { id: e3, checked: t3 });
        });
        __publicField(this, "contextMenu", function(e3) {
          __privateGet(this, _g).call(this, "contextMenu", e3);
        });
        __publicField(this, "getEntriesFromDataTransferItems", async function(e3, t3 = { raw: false }) {
          const s2 = (e4) => {
            if (this.getEntriesFromDataTransferItems.didShowInfo)
              return;
            if ("EncodingError" !== e4.name)
              return;
            this.getEntriesFromDataTransferItems.didShowInfo = true;
            const t4 = `${e4.name} occurred within datatransfer-files-promise module
Error message: "${e4.message}"
Try serving html over http if currently you are running it from the filesystem.`;
            console.warn(t4);
          }, n2 = (e4, t4) => new Promise((n3, r3) => {
            e4.readEntries(async (e5) => {
              let s3 = [];
              for (let n4 of e5) {
                const e6 = await i2(n4, t4);
                s3 = s3.concat(e6);
              }
              n3(s3);
            }, (e5) => {
              s2(e5), r3(e5);
            });
          }), i2 = async (e4, i3 = "") => {
            if (null !== e4) {
              if (e4.isFile) {
                const n3 = await ((e5, n4 = "") => new Promise((i4, r3) => {
                  e5.file((e6) => {
                    t3.raw || (e6.filepath = n4 + e6.name), i4(e6);
                  }, (e6) => {
                    s2(e6), r3(e6);
                  });
                }))(e4, i3);
                return [n3];
              }
              if (e4.isDirectory) {
                const t4 = await (async (e5, t5) => {
                  const s3 = e5.createReader(), i4 = t5 + e5.name + "/";
                  let r3, o3 = [];
                  do {
                    r3 = await n2(s3, i4), o3 = o3.concat(r3);
                  } while (r3.length > 0);
                  return o3;
                })(e4, i3);
                return t4.push(e4), t4;
              }
            }
          };
          let r2 = [], o2 = [];
          for (let t4 = 0, s3 = e3.length; t4 < s3; t4++)
            o2.push(e3[t4].webkitGetAsEntry());
          for (let e4 of o2) {
            const t4 = await i2(e4);
            r2 = r2.concat(t4);
          }
          return r2;
        });
        __publicField(this, "authenticateWithPuter", function() {
          if ("web" === this.env)
            return this.authToken ? new Promise((e3) => {
              e3();
            }) : puter.puterAuthState.isPromptOpen ? new Promise((e3, t3) => {
              puter.puterAuthState.resolver = { resolve: e3, reject: t3 };
            }) : (puter.puterAuthState.isPromptOpen = true, puter.puterAuthState.authGranted = null, new Promise((e3, t3) => {
              if (puter.authToken)
                e3();
              else {
                const s2 = new dt(e3, t3);
                document.body.appendChild(s2), s2.open();
              }
            }));
        });
        __publicField(this, "launchApp", async function(e3, t3, s2) {
          let n2;
          e3.includes("#(as)") && ([e3, n2] = e3.split("#(as)"));
          const i2 = await __privateGet(this, _m).call(this, { method: "launchApp", callback: s2, parameters: { app_name: e3, pseudonym: n2, args: t3 } });
          return ft.from(i2, this.context);
        });
        __publicField(this, "connectToInstance", async function(e3) {
          const t3 = await __privateGet(this, _m).call(this, { method: "connectToInstance", parameters: { app_name: e3 } });
          return ft.from(t3, this.context);
        });
        __publicField(this, "createWindow", function(e3, t3) {
          return new Promise((t4) => {
            __privateGet(this, _f).call(this, "createWindow", (e4) => {
              t4(e4.window);
            }, { options: e3 != null ? e3 : {} });
          });
        });
        __publicField(this, "menubar", function() {
          document.querySelectorAll("style.puter-stylesheet").forEach(function(e4) {
            e4.remove();
          });
          const e3 = document.createElement("style");
          e3.classList.add("puter-stylesheet"), e3.innerHTML = "\n        .--puter-menubar {\n            border-bottom: 1px solid #e9e9e9;\n            background-color: #fbf9f9;\n            padding-top: 3px;\n            padding-bottom: 2px;\n            display: inline-block;\n            position: fixed;\n            top: 0;\n            width: 100%;\n            margin: 0;\n            padding: 0;\n            height: 31px;\n            font-family: Arial, Helvetica, sans-serif;\n            font-size: 13px;\n            z-index: 9999;\n        }\n        \n        .--puter-menubar, .--puter-menubar * {\n            user-select: none;\n            -webkit-user-select: none;\n            cursor: default;\n        }\n        \n        .--puter-menubar .dropdown-item-divider>hr {\n            margin-top: 5px;\n            margin-bottom: 5px;\n            border-bottom: none;\n            border-top: 1px solid #00000033;\n        }\n        \n        .--puter-menubar>li {\n            display: inline-block;\n            padding: 10px 5px;\n        }\n        \n        .--puter-menubar>li>ul {\n            display: none;\n            z-index: 999999999999;\n            list-style: none;\n            background-color: rgb(233, 233, 233);\n            width: 200px;\n            border: 1px solid #e4ebf3de;\n            box-shadow: 0px 0px 5px #00000066;\n            padding-left: 6px;\n            padding-right: 6px;\n            padding-top: 4px;\n            padding-bottom: 4px;\n            color: #333;\n            border-radius: 4px;\n            padding: 2px;\n            min-width: 200px;\n            margin-top: 5px;\n            position: absolute;\n        }\n        \n        .--puter-menubar .menubar-item {\n            display: block;\n            line-height: 24px;\n            margin-top: -7px;\n            text-align: center;\n            border-radius: 3px;\n            padding: 0 5px;\n        }\n        \n        .--puter-menubar .menubar-item-open {\n            background-color: rgb(216, 216, 216);\n        }\n        \n        .--puter-menubar .dropdown-item {\n            padding: 5px;\n            padding: 5px 30px;\n            list-style-type: none;\n            user-select: none;\n            font-size: 13px;\n        }\n        \n        .--puter-menubar .dropdown-item-icon, .--puter-menubar .dropdown-item-icon-active {\n            pointer-events: none;\n            width: 18px;\n            height: 18px;\n            margin-left: -23px;\n            margin-bottom: -4px;\n            margin-right: 5px;\n        }\n        .--puter-menubar .dropdown-item-disabled .dropdown-item-icon{\n            display: inline-block !important;\n        }\n        .--puter-menubar .dropdown-item-disabled .dropdown-item-icon-active{\n            display: none !important;\n        }\n        .--puter-menubar .dropdown-item-icon-active {\n            display:none;\n        }\n        .--puter-menubar .dropdown-item:hover .dropdown-item-icon{\n            display: none;\n        }\n        .--puter-menubar .dropdown-item:hover .dropdown-item-icon-active{\n            display: inline-block;\n        }\n        .--puter-menubar .dropdown-item-hide-icon .dropdown-item-icon, .--puter-menubar .dropdown-item-hide-icon .dropdown-item-icon-active{\n            display: none !important;\n        }\n        .--puter-menubar .dropdown-item a {\n            color: #333;\n            text-decoration: none;\n        }\n        \n        .--puter-menubar .dropdown-item:hover, .--puter-menubar .dropdown-item:hover a {\n            background-color: rgb(59 134 226);\n            color: white;\n            border-radius: 4px;\n        }\n        \n        .--puter-menubar .dropdown-item-disabled, .--puter-menubar .dropdown-item-disabled:hover {\n            opacity: 0.5;\n            background-color: transparent;\n            color: initial;\n            cursor: initial;\n            pointer-events: none;\n        }\n        \n        .--puter-menubar .menubar * {\n            user-select: none;\n        }                \n        ", (document.head || document.getElementsByTagName("head")[0]).appendChild(e3), document.addEventListener("click", function(e4) {
            if (e4.target.classList.contains("dropdown-item-disabled"))
              return false;
            e4.target.classList.contains("menubar-item") || (document.querySelectorAll(".menubar-item.menubar-item-open").forEach(function(e5) {
              e5.classList.remove("menubar-item-open");
            }), document.querySelectorAll(".dropdown").forEach((e5) => e5.style.display = "none"));
          }), window.addEventListener("blur", function(e4) {
            document.querySelectorAll(".dropdown").forEach(function(e5) {
              e5.style.display = "none";
            }), document.querySelectorAll(".menubar-item.menubar-item-open").forEach((e5) => e5.classList.remove("menubar-item-open"));
          }), document.querySelectorAll(".menubar-item").forEach((e4) => e4.addEventListener("mousedown", function(e5) {
            document.querySelectorAll(".dropdown").forEach(function(e6) {
              e6.style.display = "none";
            }), document.querySelectorAll(".menubar-item.menubar-item-open").forEach(function(t3) {
              t3 != e5.target && t3.classList.remove("menubar-item-open");
            }), this.classList.contains("menubar-item-open") ? document.querySelectorAll(".menubar-item.menubar-item-open").forEach(function(e6) {
              e6.classList.remove("menubar-item-open");
            }) : e5.target.classList.contains("dropdown-item") || (this.classList.add("menubar-item-open"), function(e6) {
              const t3 = [];
              if (!e6.parentNode)
                return t3;
              let s2 = e6.parentNode.firstChild;
              for (; s2; )
                1 === s2.nodeType && s2 !== e6 && t3.push(s2), s2 = s2.nextSibling;
              return t3;
            }(this).forEach(function(e6) {
              e6.style.display = "block";
            }));
          })), document.querySelectorAll(".--puter-menubar .menubar-item").forEach((e4) => e4.addEventListener("mouseover", function(e5) {
            const t3 = document.querySelectorAll(".menubar-item.menubar-item-open");
            t3.length > 0 && t3[0] !== e5.target && e5.target.dispatchEvent(new Event("mousedown"));
          }));
        });
        __privateAdd(this, _y, null);
        __privateAdd(this, _b, null);
        if (__privateSet(this, _e3, n2), this.context = e3, this.appInstanceID = t3, this.parentInstanceID = s2, this.appID = e3.appID, this.env = e3.env, this.util = e3.util, "app" === this.env)
          this.messageTarget = window.parent;
        else if ("gui" === this.env)
          return;
        this.context = this.context.sub({ appInstanceID: this.appInstanceID, messageTarget: this.messageTarget }), this.parentInstanceID && __privateSet(this, _o, new ft(this.context, { target: this.parentInstanceID, usesSDK: true })), (_a3 = this.messageTarget) == null ? void 0 : _a3.postMessage({ msg: "READY", appInstanceID: this.appInstanceID }, "*"), window.addEventListener("focus", (e4) => {
          var _a4;
          (_a4 = this.messageTarget) == null ? void 0 : _a4.postMessage({ msg: "windowFocused", appInstanceID: this.appInstanceID }, "*");
        });
        let i2 = null;
        window.addEventListener("message", async (e4) => {
          var _a4, _b3, _c2, _d2;
          if (e4.data.error)
            throw e4.data.error;
          if (e4.data.msg && "focus" === e4.data.msg)
            window.focus();
          else if (e4.data.msg && "click" === e4.data.msg) {
            const t4 = document.elementFromPoint(e4.data.x, e4.data.y);
            null !== t4 && t4.click();
          } else if (e4.data.msg && "drag" === e4.data.msg) {
            const t4 = document.elementFromPoint(e4.data.x, e4.data.y);
            if (t4 !== i2) {
              if (i2) {
                const t5 = new Event("dragleave", { bubbles: true, cancelable: true, clientX: e4.data.x, clientY: e4.data.y });
                i2.dispatchEvent(t5);
              }
              if (t4) {
                const s3 = new Event("dragenter", { bubbles: true, cancelable: true, clientX: e4.data.x, clientY: e4.data.y });
                t4.dispatchEvent(s3);
              }
              i2 = t4;
            }
          } else if (e4.data.msg && "drop" === e4.data.msg) {
            if (i2) {
              const t4 = new CustomEvent("drop", { bubbles: true, cancelable: true, detail: { clientX: e4.data.x, clientY: e4.data.y, items: e4.data.items } });
              i2.dispatchEvent(t4), i2 = null;
            }
          } else if ("windowWillClose" === e4.data.msg)
            void 0 === __privateGet(this, _c) ? (_a4 = this.messageTarget) == null ? void 0 : _a4.postMessage({ msg: true, appInstanceID: this.appInstanceID, original_msg_id: e4.data.msg_id }, "*") : ((_b3 = this.messageTarget) == null ? void 0 : _b3.postMessage({ msg: false, appInstanceID: this.appInstanceID, original_msg_id: e4.data.msg_id }, "*"), __privateGet(this, _c).call(this));
          else if ("itemsOpened" === e4.data.msg)
            if (void 0 === __privateGet(this, _l))
              (_c2 = this.messageTarget) == null ? void 0 : _c2.postMessage({ msg: true, appInstanceID: this.appInstanceID, original_msg_id: e4.data.msg_id }, "*");
            else {
              (_d2 = this.messageTarget) == null ? void 0 : _d2.postMessage({ msg: false, appInstanceID: this.appInstanceID, original_msg_id: e4.data.msg_id }, "*");
              let t4 = [];
              if (e4.data.items.length > 0)
                for (let s3 = 0; s3 < e4.data.items.length; s3++)
                  t4.push(new ht(e4.data.items[s3]));
              __privateGet(this, _l).call(this, t4);
            }
          else if ("getAppDataSucceeded" === e4.data.msg) {
            let t4 = new ht(e4.data.item);
            e4.data.original_msg_id && __privateGet(this, _a)[e4.data.original_msg_id] && __privateGet(this, _a)[e4.data.original_msg_id](t4);
          } else if ("readAppDataFileSucceeded" === e4.data.msg) {
            let t4 = new ht(e4.data.item);
            e4.data.original_msg_id && __privateGet(this, _a)[e4.data.original_msg_id] && __privateGet(this, _a)[e4.data.original_msg_id](t4);
          } else if ("readAppDataFileFailed" === e4.data.msg)
            e4.data.original_msg_id && __privateGet(this, _a)[e4.data.original_msg_id] && __privateGet(this, _a)[e4.data.original_msg_id](null);
          else if (void 0 !== e4.data.original_msg_id && __privateGet(this, _a)[e4.data.original_msg_id]) {
            if ("fileOpenPicked" === e4.data.msg) {
              if (1 === e4.data.items.length)
                __privateGet(this, _a)[e4.data.original_msg_id](new ht(e4.data.items[0]));
              else if (e4.data.items.length > 1) {
                let t4 = [];
                for (let s3 = 0; s3 < e4.data.items.length; s3++)
                  t4.push(new ht(e4.data.items[s3]));
                __privateGet(this, _a)[e4.data.original_msg_id](t4);
              }
            } else if ("directoryPicked" === e4.data.msg) {
              if (1 === e4.data.items.length)
                __privateGet(this, _a)[e4.data.original_msg_id](new ht({ uid: e4.data.items[0].uid, name: e4.data.items[0].fsentry_name, path: e4.data.items[0].path, readURL: e4.data.items[0].read_url, writeURL: e4.data.items[0].write_url, metadataURL: e4.data.items[0].metadata_url, isDirectory: true, size: e4.data.items[0].fsentry_size, accessed: e4.data.items[0].fsentry_accessed, modified: e4.data.items[0].fsentry_modified, created: e4.data.items[0].fsentry_created }));
              else if (e4.data.items.length > 1) {
                let t4 = [];
                for (let s3 = 0; s3 < e4.data.items.length; s3++)
                  t4.push(new ht(e4.data.items[s3]));
                __privateGet(this, _a)[e4.data.original_msg_id](t4);
              }
            } else
              "colorPicked" === e4.data.msg ? __privateGet(this, _a)[e4.data.original_msg_id](e4.data.color) : "fontPicked" === e4.data.msg ? __privateGet(this, _a)[e4.data.original_msg_id](e4.data.font) : "alertResponded" === e4.data.msg || "promptResponded" === e4.data.msg ? __privateGet(this, _a)[e4.data.original_msg_id](e4.data.response) : "fileSaved" === e4.data.msg ? __privateGet(this, _a)[e4.data.original_msg_id](new ht(e4.data.saved_file)) : __privateGet(this, _a)[e4.data.original_msg_id](e4.data);
            delete __privateGet(this, _a)[e4.data.original_msg_id];
          } else if ("itemChanged" === e4.data.msg && e4.data.data && e4.data.data.uid)
            this.itemWatchCallbackFunctions[e4.data.data.uid] && "function" == typeof this.itemWatchCallbackFunctions[e4.data.data.uid] && this.itemWatchCallbackFunctions[e4.data.data.uid](e4.data.data);
          else if ("broadcast" === e4.data.msg) {
            const { name: t4, data: s3 } = e4.data;
            if (!__privateGet(this, _e3).includes(t4))
              return;
            this.emit(t4, s3), __privateGet(this, _u).set(t4, s3);
          } else if ("connection" === e4.data.msg) {
            e4.data.usesSDK = true;
            const t4 = ft.from(e4.data, this.context), s3 = (t5) => {
              var _a5;
              (_a5 = this.messageTarget) == null ? void 0 : _a5.postMessage({ $: "connection-resp", connection: e4.data.appInstanceID, accept: true, value: t5 }, "*");
            }, n3 = (t5) => {
              var _a5;
              (_a5 = this.messageTarget) == null ? void 0 : _a5.postMessage({ $: "connection-resp", connection: e4.data.appInstanceID, accept: false, value: t5 }, "*");
            };
            this.emit("connection", { conn: t4, accept: s3, reject: n3 });
          }
        }), document.addEventListener("mousemove", async (e4) => {
          var _a4;
          this.mouseX = e4.clientX, this.mouseY = e4.clientY, (_a4 = this.messageTarget) == null ? void 0 : _a4.postMessage({ msg: "mouseMoved", appInstanceID: this.appInstanceID, x: this.mouseX, y: this.mouseY }, "*");
        }), document.addEventListener("click", async (e4) => {
          var _a4;
          this.mouseX = e4.clientX, this.mouseY = e4.clientY, (_a4 = this.messageTarget) == null ? void 0 : _a4.postMessage({ msg: "mouseClicked", appInstanceID: this.appInstanceID, x: this.mouseX, y: this.mouseY }, "*");
        });
      }
      parentApp() {
        return __privateGet(this, _o);
      }
      on(e3, t3) {
        super.on(e3, t3), __privateGet(this, _e3).includes(e3) && __privateGet(this, _u).has(e3) && t3(__privateGet(this, _u).get(e3));
      }
      showSpinner() {
        if (__privateGet(this, _d))
          return;
        if (!document.getElementById("puter-spinner-styles")) {
          const e4 = document.createElement("style");
          e4.id = "puter-spinner-styles", e4.textContent = "\n                .puter-loading-spinner {\n                    width: 50px;\n                    height: 50px;\n                    border: 5px solid #f3f3f3;\n                    border-top: 5px solid #3498db;\n                    border-radius: 50%;\n                    animation: spin 1s linear infinite;\n                    margin-bottom: 10px;\n                }\n    \n                .puter-loading-text {\n                    font-family: Arial, sans-serif;\n                    font-size: 16px;\n                    margin-top: 10px;\n                    text-align: center;\n                }\n    \n                @keyframes spin {\n                    0% { transform: rotate(0deg); }\n                    100% { transform: rotate(360deg); }\n                }\n    \n                .puter-loading-container {\n                    display: flex;\n                    flex-direction: column;\n                    align-items: center;\n                    justify-content: center;\n                    width: 120px; \n                    height: 120px; \n                    background: #ffffff; \n                    border-radius: 10px;\n                }\n            ", document.head.appendChild(e4);
        }
        const e3 = document.createElement("div");
        e3.classList.add("puter-loading-overlay"), Object.assign(e3.style, { position: "fixed", top: "0", left: "0", width: "100%", height: "100%", backgroundColor: "rgba(255, 255, 255, 0.8)", zIndex: "2147483647", display: "flex", justifyContent: "center", alignItems: "center", pointerEvents: "all" });
        const t3 = document.createElement("div");
        t3.classList.add("puter-loading-container"), t3.innerHTML = '\n            <div class="puter-loading-spinner"></div>\n            <div class="puter-loading-text">Working...</div>\n        ', e3.appendChild(t3), document.body.appendChild(e3), __privateSet(this, _d, true), __privateSet(this, _y, Date.now()), __privateSet(this, _p, setTimeout(() => {
          __privateSet(this, _p, null);
        }, 1e3));
      }
      hideSpinner() {
        if (!__privateGet(this, _d))
          return;
        __privateGet(this, _p) && (clearTimeout(__privateGet(this, _p)), __privateSet(this, _p, null));
        const e3 = Date.now() - __privateGet(this, _y), t3 = Math.max(0, 1200 - e3);
        t3 > 0 ? (__privateGet(this, _b) && clearTimeout(__privateGet(this, _b)), __privateSet(this, _b, setTimeout(() => {
          __privateMethod(this, _w, w_fn).call(this);
        }, t3))) : __privateMethod(this, _w, w_fn).call(this);
      }
      isWorkingActive() {
        return __privateGet(this, _d);
      }
    }, _r = new WeakMap(), _o = new WeakMap(), _a = new WeakMap(), _c = new WeakMap(), _l = new WeakMap(), _h = new WeakMap(), _e3 = new WeakMap(), _u = new WeakMap(), _d = new WeakMap(), _p = new WeakMap(), _f = new WeakMap(), _g = new WeakMap(), _m = new WeakMap(), _y = new WeakMap(), _b = new WeakMap(), _w = new WeakSet(), w_fn = function() {
      var _a3;
      const e3 = document.querySelector(".puter-loading-overlay");
      e3 && ((_a3 = e3.parentNode) == null ? void 0 : _a3.removeChild(e3)), __privateSet(this, _d, false), __privateSet(this, _y, null), __privateSet(this, _b, null);
    }, _a2), mt = ["has_set_default_app_user_permissions", "window_sidebar_width", "sidebar_items", "menubar_style", "user_preferences.auto_arrange_desktop", "user_preferences.show_hidden_files", "user_preferences.language", "user_preferences.clock_visible", "has_seen_welcome_window"];
    function yt(e3, t3) {
      let s2 = (n2 = e3, n2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).replace(/\\\*/g, ".*").replace(/\\\?/g, ".").replace(/\\\[/g, "[").replace(/\\\]/g, "]").replace(/\\\^/g, "^");
      var n2;
      return new RegExp("^" + s2 + "$").test(t3);
    }
    const bt = class {
      MAX_KEY_SIZE = 1024;
      MAX_VALUE_SIZE = 409600;
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID, this.gui_cached = new st.TeePromise(), this.gui_cache_init = new st.TeePromise(), (async () => {
          await this.gui_cache_init, this.gui_cache_init = null;
          const e4 = await fetch(`${this.APIOrigin}/drivers/call`, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.authToken}` }, body: JSON.stringify({ interface: "puter-kvstore", method: "get", args: { key: mt } }) }), t3 = await e4.json(), s2 = {};
          for (let e5 = 0; e5 < mt.length; e5++)
            s2[mt[e5]] = t3.result[e5];
          this.gui_cached.resolve(s2), setTimeout(() => {
            this.gui_cached = null;
          }, 4e3);
        })();
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      set = c(["key", "value"], "puter-kvstore", void 0, "set", { preprocess: (e3) => {
        if (void 0 === e3.key || null === e3.key)
          throw { message: "Key cannot be undefined", code: "key_undefined" };
        if (e3.key.length > this.MAX_KEY_SIZE)
          throw { message: "Key size cannot be larger than " + this.MAX_KEY_SIZE, code: "key_too_large" };
        if (e3.value && e3.value.length > this.MAX_VALUE_SIZE)
          throw { message: "Value size cannot be larger than " + this.MAX_VALUE_SIZE, code: "value_too_large" };
        return e3;
      } });
      async get(...e3) {
        return "string" == typeof e3[0] && mt.includes(e3[0]) && null !== this.gui_cached ? (this.gui_cache_init && this.gui_cache_init.resolve(), (await this.gui_cached)[e3[0]]) : await this.get_(...e3);
      }
      get_ = c(["key"], "puter-kvstore", void 0, "get", { preprocess: (e3) => {
        if (e3.key.length > this.MAX_KEY_SIZE)
          throw { message: "Key size cannot be larger than " + this.MAX_KEY_SIZE, code: "key_too_large" };
        return e3;
      }, transform: (e3) => e3 });
      incr = async (...e3) => {
        var _a3;
        let t3 = {};
        if (!e3 || 0 === e3.length)
          throw { message: "Arguments are required", code: "arguments_required" };
        if (t3.key = e3[0], t3.amount = (_a3 = e3[1]) != null ? _a3 : 1, t3.key.length > this.MAX_KEY_SIZE)
          throw { message: "Key size cannot be larger than " + this.MAX_KEY_SIZE, code: "key_too_large" };
        return c(["key"], "puter-kvstore", void 0, "incr").call(this, t3);
      };
      decr = async (...e3) => {
        var _a3;
        let t3 = {};
        if (!e3 || 0 === e3.length)
          throw { message: "Arguments are required", code: "arguments_required" };
        if (t3.key = e3[0], t3.amount = (_a3 = e3[1]) != null ? _a3 : 1, t3.key.length > this.MAX_KEY_SIZE)
          throw { message: "Key size cannot be larger than " + this.MAX_KEY_SIZE, code: "key_too_large" };
        return c(["key"], "puter-kvstore", void 0, "decr").call(this, t3);
      };
      del = c(["key"], "puter-kvstore", void 0, "del", { preprocess: (e3) => {
        if (e3.key.length > this.MAX_KEY_SIZE)
          throw { message: "Key size cannot be larger than " + this.MAX_KEY_SIZE, code: "key_too_large" };
        return e3;
      } });
      list = async (...e3) => {
        let t3, s2 = {}, n2 = false;
        return e3 && 1 === e3.length && true === e3[0] || e3 && 2 === e3.length && true === e3[1] ? (s2 = {}, n2 = true) : s2 = { as: "keys" }, (e3 && 1 === e3.length && "string" == typeof e3[0] || e3 && 2 === e3.length && "string" == typeof e3[0] && true === e3[1]) && (t3 = e3[0]), c([], "puter-kvstore", void 0, "list", { transform: (e4) => t3 ? n2 ? e4.filter((e5) => yt(t3, e5.key)) : e4.filter((e5) => yt(t3, e5)) : e4 }).call(this, s2);
      };
      flush = c([], "puter-kvstore", void 0, "flush");
      clear = this.flush;
    }, wt = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async listModels(e3) {
        const t3 = {}, s2 = await puter.drivers.call("puter-chat-completion", "ai-chat", "models");
        return s2 && s2.result && Array.isArray(s2.result) ? (s2.result.forEach((s3) => {
          s3.provider && s3.id && (e3 && s3.provider !== e3 || (t3[s3.provider] || (t3[s3.provider] = []), t3[s3.provider].push(s3.id)));
        }), t3) : t3;
      }
      async listModelProviders() {
        let e3 = [];
        const t3 = await puter.drivers.call("puter-chat-completion", "ai-chat", "models");
        return t3 && t3.result && Array.isArray(t3.result) ? (e3 = /* @__PURE__ */ new Set(), t3.result.forEach((t4) => {
          t4.provider && e3.add(t4.provider);
        }), e3 = Array.from(e3), e3) : e3;
      }
      img2txt = async (...e3) => {
        let t3 = {}, s2 = false;
        if (!e3)
          throw { message: "Arguments are required", code: "arguments_required" };
        if (("string" == typeof e3[0] || e3[0] instanceof Blob) && (t3.source = e3[0]), e3[0].source instanceof Blob && (t3.source = await d(e3[0].source)), t3.source.length > this.MAX_INPUT_SIZE)
          throw { message: "Input size cannot be larger than 10485760", code: "input_too_large" };
        return ("boolean" == typeof e3[1] && true === e3[1] || "boolean" == typeof e3[2] && true === e3[2] || "boolean" == typeof e3[3] && true === e3[3]) && (s2 = true), await c(["source"], "puter-ocr", "aws-textract", "recognize", { test_mode: s2 != null ? s2 : false, transform: async (e4) => {
          var _a3;
          let t4 = "";
          for (let s3 = 0; s3 < ((_a3 = e4 == null ? void 0 : e4.blocks) == null ? void 0 : _a3.length); s3++)
            "text/textract:LINE" === e4.blocks[s3].type && (t4 += e4.blocks[s3].text + "\n");
          return t4;
        } }).call(this, t3);
      };
      txt2speech = async (...e3) => {
        let t3 = {}, s2 = false;
        if (!e3)
          throw { message: "Arguments are required", code: "arguments_required" };
        if ("string" == typeof e3[0] && (t3 = { text: e3[0] }), e3[1] && "string" == typeof e3[1] && (t3.language = e3[1]), t3.text.length > this.MAX_INPUT_SIZE)
          throw { message: "Input size cannot be larger than 3000", code: "input_too_large" };
        return ("boolean" == typeof e3[1] && true === e3[1] || "boolean" == typeof e3[2] && true === e3[2] || "boolean" == typeof e3[3] && true === e3[3]) && (s2 = true), await c(["source"], "puter-tts", "aws-polly", "synthesize", { responseType: "blob", test_mode: s2 != null ? s2 : false, transform: async (e4) => {
          const t4 = await u(e4), s3 = new Audio(t4);
          return s3.toString = () => t4, s3.valueOf = () => t4, s3;
        } }).call(this, t3);
      };
      chat = async (...e3) => {
        var _a3;
        let t3 = {}, s2 = {}, n2 = false, i2 = "openai-completion";
        if (!e3)
          throw { message: "Arguments are required", code: "arguments_required" };
        if ("string" == typeof e3[0] && (t3 = { messages: [{ content: e3[0] }] }), "string" != typeof e3[0] || e3[1] && "boolean" != typeof e3[1])
          if ("string" == typeof e3[0] && ("string" == typeof e3[1] || e3[1] instanceof File))
            e3[1] instanceof File && (e3[1] = await d(e3[1])), t3 = { vision: true, messages: [{ content: [e3[0], { image_url: { url: e3[1] } }] }] };
          else if ("string" == typeof e3[0] && Array.isArray(e3[1])) {
            for (let t4 = 0; t4 < e3[1].length; t4++)
              e3[1][t4] = { image_url: { url: e3[1][t4] } };
            t3 = { vision: true, messages: [{ content: [e3[0], ...e3[1]] }] };
          } else
            Array.isArray(e3[0]) && (t3 = { messages: e3[0] });
        else
          t3 = { messages: [{ content: e3[0] }] };
        ("boolean" == typeof e3[1] && true === e3[1] || "boolean" == typeof e3[2] && true === e3[2] || "boolean" == typeof e3[3] && true === e3[3]) && (n2 = true);
        const r2 = (e4) => "object" == typeof e4 && !Array.isArray(e4) && null !== e4;
        for (let t4 = 0; t4 < e3.length; t4++)
          if (r2(e3[t4])) {
            s2 = e3[t4];
            break;
          }
        s2.model && (t3.model = s2.model), s2.temperature && (t3.temperature = s2.temperature), s2.max_tokens && (t3.max_tokens = s2.max_tokens), t3.model = (_a3 = t3.model) != null ? _a3 : "", t3.model && t3.model.startsWith("anthropic/") && (t3.model = t3.model.replace("anthropic/", "")), "claude-3-5-sonnet" === t3.model && (t3.model = "claude-3-5-sonnet-latest"), "claude-3-7-sonnet" !== t3.model && "claude" !== t3.model || (t3.model = "claude-3-7-sonnet-latest"), "mistral" === t3.model && (t3.model = "mistral-large-latest"), "groq" === t3.model && (t3.model = "llama3-8b-8192"), "deepseek" === t3.model && (t3.model = "deepseek-chat"), "o1-mini" !== t3.model && "o1-pro" !== t3.model || (t3.model = "openrouter:openai/o1-mini"), t3.model && t3.model.startsWith("openai/") && (t3.model = t3.model.replace("openai/", ""), i2 = "openai-completion"), (t3.model.startsWith("meta-llama/") || t3.model.startsWith("google/") || t3.model.startsWith("deepseek/") || t3.model.startsWith("x-ai/")) && (t3.model = "openrouter:" + t3.model), !t3.model || t3.model.startsWith("gpt-") ? i2 = "openai-completion" : "claude-3-haiku-20240307" === t3.model || "claude-3-5-sonnet-20240620" === t3.model || "claude-3-5-sonnet-20241022" === t3.model || "claude-3-5-sonnet-latest" === t3.model || "claude-3-7-sonnet-latest" === t3.model ? i2 = "claude" : "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo" === t3.model || "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo" === t3.model || "meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo" === t3.model || "google/gemma-2-27b-it" === t3.model ? i2 = "together-ai" : "mistral-large-latest" === t3.model || "codestral-latest" === t3.model ? i2 = "mistral" : ["distil-whisper-large-v3-en", "gemma2-9b-it", "gemma-7b-it", "llama-3.1-70b-versatile", "llama-3.1-8b-instant", "llama3-70b-8192", "llama3-8b-8192", "llama3-groq-70b-8192-tool-use-preview", "llama3-groq-8b-8192-tool-use-preview", "llama-guard-3-8b", "mixtral-8x7b-32768", "whisper-large-v3"].includes(t3.model) ? i2 = "groq" : "grok-beta" === t3.model ? i2 = "xai" : "deepseek-chat" === t3.model || "deepseek-reasoner" === t3.model ? i2 = "deepseek" : "gemini-1.5-flash" === t3.model || "gemini-2.0-flash" === t3.model ? i2 = "gemini" : t3.model.startsWith("openrouter:") && (i2 = "openrouter"), void 0 !== s2.stream && "boolean" == typeof s2.stream && (t3.stream = s2.stream), s2.driver && (i2 = s2.driver);
        const o2 = ["tools", "response"];
        for (const e4 of o2)
          s2[e4] && (t3[e4] = s2[e4]);
        return "" === t3.model && delete t3.model, await c(["messages"], "puter-chat-completion", i2, "complete", { test_mode: n2 != null ? n2 : false, transform: async (e4) => (e4.toString = () => {
          var _a4;
          return (_a4 = e4.message) == null ? void 0 : _a4.content;
        }, e4.valueOf = () => {
          var _a4;
          return (_a4 = e4.message) == null ? void 0 : _a4.content;
        }, e4) }).call(this, t3);
      };
      txt2img = async (...e3) => {
        let t3 = {}, s2 = false;
        if (!e3)
          throw { message: "Arguments are required", code: "arguments_required" };
        return "string" == typeof e3[0] && (t3 = { prompt: e3[0] }), "boolean" == typeof e3[1] && true === e3[1] && (s2 = true), await c(["prompt"], "puter-image-generation", void 0, "generate", { responseType: "blob", test_mode: s2 != null ? s2 : false, transform: async (e4) => {
          let t4 = new Image();
          return t4.src = await u(e4), t4.toString = () => t4.src, t4.valueOf = () => t4.src, t4;
        } }).call(this, t3);
      };
    }, vt = (_b2 = class {
      constructor(e3) {
        __privateAdd(this, _r2, 1);
        __publicField(this, "signIn", () => new Promise((e3, t3) => {
          let s2 = __privateWrapper(this, _r2)._++;
          var n2 = screen.width / 2 - 300, i2 = screen.height / 2 - 300;
          window.open(puter.defaultGUIOrigin + "/action/sign-in?embedded_in_popup=true&msg_id=" + s2 + (window.crossOriginIsolated ? "&cross_origin_isolated=true" : ""), "Puter", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=600, height=600, top=" + i2 + ", left=" + n2), window.addEventListener("message", function(n3) {
            n3.data.msg_id == s2 && (delete n3.data.msg_id, delete n3.data.msg, n3.data.success ? (puter.setAuthToken(n3.data.token), e3(n3.data)) : t3(n3.data), window.removeEventListener("message", this));
          });
        }));
        __publicField(this, "isSignedIn", () => !!puter.authToken);
        __publicField(this, "getUser", function(...e3) {
          let t3;
          return t3 = "object" == typeof e3[0] && null !== e3[0] ? e3[0] : { success: e3[0], error: e3[1] }, new Promise((e4, s2) => {
            const i2 = n("/whoami", puter.APIOrigin, puter.authToken, "get");
            r(i2, t3.success, t3.error, e4, s2), i2.send();
          });
        });
        __publicField(this, "signOut", () => {
          puter.resetAuthToken();
        });
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async whoami() {
        const e3 = await fetch(this.APIOrigin + "/whoami", { headers: { Authorization: `Bearer ${this.authToken}` } });
        return await e3.json();
      }
    }, _r2 = new WeakMap(), _b2), _t = "9a9c83a4-7897-43a0-93b9-53217b84fde6";
    class At {
      constructor() {
        __privateAdd(this, _v, 1);
        this.callbacks = /* @__PURE__ */ new Map();
      }
      register_callback(e3) {
        const t3 = __privateWrapper(this, _v)._++;
        return this.callbacks.set(t3, e3), t3;
      }
      attach_to_source(e3) {
        e3.addEventListener("message", (e4) => {
          const { data: t3 } = e4;
          if (t3 && "object" == typeof t3 && t3.$SCOPE === _t) {
            const { id: e5, args: s2 } = t3, n2 = this.callbacks.get(e5);
            n2 && n2(...s2);
          }
        });
      }
    }
    _v = new WeakMap();
    class kt {
      constructor({ callbackManager: e3 }) {
        this.callbackManager = e3;
      }
      dehydrate(e3) {
        return this.dehydrate_value_(e3);
      }
      dehydrate_value_(e3) {
        if ("function" == typeof e3) {
          const t3 = this.callbackManager.register_callback(e3);
          return { $SCOPE: _t, id: t3 };
        }
        if (Array.isArray(e3))
          return e3.map(this.dehydrate_value_.bind(this));
        if ("object" == typeof e3 && null !== e3) {
          const t3 = {};
          for (const s2 in e3)
            t3[s2] = this.dehydrate_value_(e3[s2]);
          return t3;
        }
        return e3;
      }
    }
    class It {
      constructor({ target: e3 }) {
        this.target = e3;
      }
      hydrate(e3) {
        return this.hydrate_value_(e3);
      }
      hydrate_value_(e3) {
        if (e3 && "object" == typeof e3 && e3.$SCOPE === _t) {
          const { id: t3 } = e3;
          return (...e4) => {
            this.target.postMessage({ $SCOPE: _t, id: t3, args: e4 }, "*");
          };
        }
        if (Array.isArray(e3))
          return e3.map(this.hydrate_value_.bind(this));
        if ("object" == typeof e3 && null !== e3) {
          const t3 = {};
          for (const s2 in e3)
            t3[s2] = this.hydrate_value_(e3[s2]);
          return t3;
        }
        return e3;
      }
    }
    class Tt {
      constructor() {
        this.rpc = new xt();
      }
    }
    class xt {
      constructor() {
        this.callbackManager = new At(), this.callbackManager.attach_to_source(window);
      }
      getDehydrator() {
        return new kt({ callbackManager: this.callbackManager });
      }
      getHydrator({ target: e3 }) {
        return new It({ target: e3 });
      }
      registerCallback(e3) {
        return this.callbackManager.register_callback(e3);
      }
      send(e3, t3, ...s2) {
        e3.postMessage({ $SCOPE: _t, id: t3, args: s2 }, "*");
      }
    }
    class Et {
      constructor({ context: e3 }) {
        this.context = e3, this.response_handlers = this.constructor.response_handlers;
      }
      static response_handlers = { "application/x-ndjson": async (e3) => async function* (e4) {
        const t3 = e4.getReader();
        let s2, n2;
        for (; !n2 && ({ value: s2, done: n2 } = await t3.read(), !n2); ) {
          const e5 = new TextDecoder().decode(s2).split("\n");
          for (const t4 of e5)
            "" !== t4.trim() && (yield JSON.parse(t4));
        }
      }(e3.body), "application/json": async (e3) => await e3.json(), "application/octet-stream": async (e3) => await e3.blob() };
      async call({ driver: e3, method_name: t3, parameters: s2 }) {
        const n2 = await fetch(`${this.context.APIOrigin}/drivers/call`, { headers: { Authorization: `Bearer ${this.context.authToken}`, "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ interface: e3.iface_name, ...e3.service_name ? { service: e3.service_name } : {}, method: t3, args: s2 }) }), i2 = n2.headers.get("content-type").split(";")[0].trim(), r2 = this.response_handlers[i2];
        if (!r2) {
          const e4 = `unrecognized content type: ${i2}`;
          throw console.error(e4), console.error("creating blob so dev tools shows response..."), await n2.blob(), new Error(e4);
        }
        return await r2(n2);
      }
    }
    class Pt {
      constructor({ iface: e3, iface_name: t3, service_name: s2, call_backend: n2 }) {
        this.iface = e3, this.iface_name = t3, this.service_name = s2, this.call_backend = n2;
      }
      async call(e3, t3) {
        return await this.call_backend.call({ driver: this, method_name: e3, parameters: t3 });
      }
    }
    const St = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID, this.drivers_ = {}, this.context = {}, Object.defineProperty(this.context, "authToken", { get: () => this.authToken }), Object.defineProperty(this.context, "APIOrigin", { get: () => this.APIOrigin });
      }
      _init({ puter: e3 }) {
        e3.call = this.call.bind(this);
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async list() {
        const e3 = await fetch(`${this.APIOrigin}/lsmod`, { headers: { Authorization: "Bearer " + this.authToken }, method: "POST" });
        return (await e3.json()).interfaces;
      }
      async get(e3, t3) {
        t3 || (t3 = e3);
        const s2 = `${e3}:${t3}`;
        if (this.drivers_[s2])
          return this.drivers_[s2];
        const n2 = await this.list();
        if (!n2[e3])
          throw new Error(`Interface ${e3} not found`);
        return this.drivers_[s2] = new Pt({ call_backend: new Et({ context: this.context }), iface: n2[e3], iface_name: e3, service_name: t3 });
      }
      async call(...e3) {
        let t3, s2, n2, i2;
        4 === e3.length ? [t3, s2, n2, i2] = e3 : 3 === e3.length ? [t3, n2, i2] = e3 : 2 === e3.length && ([t3, i2] = e3, n2 = t3);
        const r2 = await this.get(t3, s2);
        return await r2.call(n2, i2);
      }
    }, Ot = { id: "f485f1ba-de07-422c-8c4b-c2da057d4a44", uid: "f485f1ba-de07-422c-8c4b-c2da057d4a44", is_dir: true, immutable: true, name: "FromParentWindow" };
    class Ct extends $e.concepts.Service {
      async _init() {
        const e3 = this._.context.services, t3 = this._.context.util;
        e3.get("xd-incoming").register_tagged_listener("puter-fs", (e4) => {
          t3.rpc.send(e4.source, e4.data.$callback, [Ot]);
        });
      }
    }
    const Dt = { id: "f485f1ba-de07-422c-8c4b-c2da057d4a44", uid: "f485f1ba-de07-422c-8c4b-c2da057d4a44", is_dir: true, immutable: true, name: "Test" };
    class Mt extends $e.AdvancedBase {
      constructor({ rpc: e3, messageTarget: t3 }) {
        super(), this.rpc = e3, this.messageTarget = t3;
      }
      static IMPLEMENTS = { [et]: { stat: async function(e3) {
        return Dt;
      }, readdir: async function(e3) {
        const t3 = new $e.libs.promise.TeePromise(), s2 = this.rpc.registerCallback((e4) => {
          t3.resolve(e4);
        });
        return this.messageTarget.postMessage({ $: "puter-fs", $callback: s2, op: "readdir", args: e3 }, "*"), await t3;
      } } };
    }
    class Lt extends $e.concepts.Service {
      static PROPERTIES = {};
      static DEPENDS = ["api-access"];
      static HOOKS = [{ service: "api-access", event: "update", description: "\n                re-initialize the socket connection whenever the\n                authentication token or API origin is changed.\n            ", async do() {
        this.initializeSocket();
      } }];
      _init() {
        this._.context.env, this.init_top_fs_(), this.initializeSocket();
      }
      init_app_fs_() {
        this.fs_nocache_ = new Mt({ messageTarget: window.parent, rpc: this._.context.util.rpc }).as(et), this.filesystem = this.fs_nocache_;
      }
      init_top_fs_() {
        const e3 = this._.context.services.get("api-access").get_api_info();
        this.fs_nocache_ = new rt({ api_info: e3 }).as(et), this.fs_cache_ = new it({ delegate: this.fs_nocache_ }).as(et), this.fs_proxy_ = new tt({ delegate: this.fs_nocache_ }), this.filesystem = this.fs_proxy_.as(et);
      }
      cache_on() {
        this.fs_proxy_.delegate = this.fs_cache_;
      }
      cache_off() {
        this.fs_proxy_.delegate = this.fs_nocache_;
      }
      async initializeSocket() {
        this.socket && this.socket.disconnect();
        const e3 = this._.context.services.get("api-access").get_api_info();
        void 0 !== e3.api_origin && (this.socket = Le(e3.api_origin, { auth: { auth_token: e3.auth_token } }), this.bindSocketEvents());
      }
      bindSocketEvents() {
        this.socket.on("connect", () => {
          puter.debugMode && console.log("FileSystem Socket: Connected", this.socket.id);
        }), this.socket.on("disconnect", () => {
          puter.debugMode && console.log("FileSystem Socket: Disconnected");
        }), this.socket.on("reconnect", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnected", this.socket.id);
        }), this.socket.on("reconnect_attempt", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Attemps", e3);
        }), this.socket.on("reconnect_error", (e3) => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Error", e3);
        }), this.socket.on("reconnect_failed", () => {
          puter.debugMode && console.log("FileSystem Socket: Reconnection Failed");
        }), this.socket.on("error", (e3) => {
          puter.debugMode && console.error("FileSystem Socket Error:", e3);
        });
      }
    }
    const { TTopics: Rt } = $e.traits;
    class Ut extends $e.concepts.Service {
      static TOPICS = ["update"];
      static PROPERTIES = { auth_token: { post_set(e3) {
        this.as(Rt).pub("update");
      } }, api_origin: { post_set() {
        this.as(Rt).pub("update");
      } } };
      get_api_info() {
        const e3 = this, t3 = {};
        return [["auth_token", "auth_token"], ["authToken", "auth_token"], ["APIOrigin", "api_origin"], ["api_origin", "api_origin"]].forEach(([s2, n2]) => {
          Object.defineProperty(t3, s2, { get: () => e3[n2], set: (t4) => e3 });
        }), t3;
      }
    }
    const Bt = $e.libs.promise.TeePromise;
    class Nt extends $e.concepts.Service {
      _construct() {
        this.filter_listeners_ = [], this.tagged_listeners_ = {};
      }
      _init() {
        window.addEventListener("message", async (e3) => {
          for (const t4 of this.filter_listeners_) {
            const s3 = new Bt();
            if (t4(e3, s3), await s3)
              return;
          }
          const t3 = e3.data, s2 = t3.$;
          if (s2 && this.tagged_listeners_[s2])
            for (const n2 of this.tagged_listeners_[s2])
              n2({ data: t3, source: e3.source });
        });
      }
      register_filter_listener(e3) {
        this.filter_listeners_.push(e3);
      }
      register_tagged_listener(e3, t3) {
        this.tagged_listeners_[e3] || (this.tagged_listeners_[e3] = []), this.tagged_listeners_[e3].push(t3);
      }
    }
    class qt extends $e.concepts.Service {
      _init() {
        if (window.when_puter_happens && (!puter || "gui" === puter.env)) {
          Array.isArray(window.when_puter_happens) || (window.when_puter_happens = [window.when_puter_happens]);
          for (const e3 of window.when_puter_happens)
            e3({ context: this._.context });
        }
      }
    }
    class Ft {
      constructor(e3, t3) {
        this.context = e3, this.parameters = t3, this._init();
      }
      _init() {
        let e3 = new URL(location.href).searchParams.get("enabled_logs");
        e3 || (e3 = ""), e3 = e3.split(";");
        for (const t3 of e3)
          "" !== t3 && this.context.puter.log.on(t3);
        window.addEventListener("message", async (e4) => {
          e4.source === window.parent && e4.data.$ && "puterjs-debug" === e4.data.$ && (console.log("Got a puter.js debug event!", e4.data), "log.on" === e4.data.cmd && (console.log("Got instruction to turn logs on!"), this.context.puter.log.on(e4.data.category)));
        });
      }
    }
    const jt = new TextDecoder(), zt = new TextEncoder(), Wt = { 1: "Reason unspecified or unknown. Returning a more specific reason should be preferred.", 3: "Unexpected stream closure due to a network error.", 65: "Stream creation failed due to invalid information. This could be sent if the destination was a reserved address or the port is invalid.", 66: "Stream creation failed due to an unreachable destination host. This could be sent if the destination is an domain which does not resolve to anything.", 67: "Stream creation timed out due to the destination server not responding.", 68: "Stream creation failed due to the destination server refusing the connection.", 71: "TCP data transfer timed out.", 72: "Stream destination address/domain is intentionally blocked by the proxy server.", 73: "Connection throttled by the server." };
    function Xt(e3) {
      let t3 = 5;
      switch (e3.packetType) {
        case 1:
          e3.hostEncoded = zt.encode(e3.hostname), t3 += 3 + e3.hostEncoded.length;
          break;
        case 2:
          t3 += e3.payload.byteLength;
          break;
        case 3:
          t3 += 4;
          break;
        case 4:
          t3 += 1;
          break;
        case 5:
          t3 += 2, e3.password && (t3 += 6), e3.puterAuth && (e3.passwordEncoded = zt.encode(e3.puterAuth), t3 += 8 + e3.passwordEncoded.length);
          break;
        default:
          throw new Error("Not supported");
      }
      let s2 = new Uint8Array(t3);
      const n2 = new DataView(s2.buffer);
      switch (n2.setUint8(0, e3.packetType), n2.setUint32(1, e3.streamID, true), e3.packetType) {
        case 1:
          n2.setUint8(5, e3.streamType), n2.setUint16(6, e3.port, true), s2.set(e3.hostEncoded, 8);
          break;
        case 2:
          s2.set(e3.payload, 5);
          break;
        case 3:
          n2.setUint32(5, e3.remainingBuffer, true);
          break;
        case 4:
          n2.setUint8(5, e3.reason);
          break;
        case 5:
          n2.setUint8(5, 2), n2.setUint8(6, 0), e3.password && (n2.setUint8(7, 2), n2.setUint32(8, 1, true), n2.setUint8(12, 0)), e3.puterAuth && (n2.setUint8(7, 2), n2.setUint32(8, 5 + e3.passwordEncoded.length, true), n2.setUint8(12, 0), n2.setUint16(13, e3.passwordEncoded.length, true), s2.set(e3.passwordEncoded, 15));
      }
      return s2;
    }
    const Vt = new TextEncoder();
    let Gt, Kt = { server: "wss://puter.cafe/", handler: void 0 };
    class Yt extends pt {
      _events = /* @__PURE__ */ new Map();
      _streamID;
      constructor(e3, t3) {
        super(["data", "drain", "open", "error", "close", "tlsdata", "tlsopen"]);
        const s2 = { dataCallBack: (e4) => {
          this.emit("data", e4);
        }, closeCallBack: (e4) => {
          if (2 !== e4)
            return this.emit("error", new Error(Wt[e4])), void this.emit("close", true);
          this.emit("close", false);
        } };
        this._streamID = Kt.handler.register(e3, t3, s2), setTimeout(() => {
          this.emit("open", void 0);
        }, 0);
      }
      addListener(...e3) {
        this.on(...e3);
      }
      write(e3, t3) {
        if (e3.buffer)
          Kt.handler.write(this._streamID, e3), t3 && t3();
        else if (e3.resize)
          e3.write(this._streamID, new Uint8Array(e3)), t3 && t3();
        else {
          if ("string" != typeof e3)
            throw new Error("Invalid data type (not TypedArray, ArrayBuffer or String!!)");
          Kt.handler.write(this._streamID, Vt.encode(e3)), t3 && t3();
        }
      }
      close() {
        Kt.handler.close(this._streamID);
      }
    }
    class Ht extends Yt {
      constructor(...e3) {
        super(...e3), (async () => {
          Gt || (Gt = await Promise.resolve().then(() => __toESM(__require("https://puter-net.b-cdn.net/rustls.js"))), await Gt.default("https://puter-net.b-cdn.net/rustls.wasm"));
          let t3 = false;
          const s2 = new ReadableStream({ start: (e4) => {
            super.on("data", (t4) => {
              e4.enqueue(t4.buffer);
            }), super.on("close", () => {
              t3 || e4.close();
            });
          }, pull: (e4) => {
          }, cancel: () => {
            t3 = true;
          } }), n2 = new WritableStream({ write: (e4) => {
            super.write(e4);
          }, abort: () => {
            console.log("hello"), super.close();
          }, close: () => {
            super.close();
          } });
          let i2, r2;
          try {
            const t4 = await Gt.connect_tls(s2, n2, e3[0]);
            i2 = t4.read, r2 = t4.write;
          } catch (e4) {
            return void this.emit("error", new Error("TLS Handshake failed: " + e4));
          }
          this.writer = r2.getWriter();
          let o2 = i2.getReader(), a2 = false;
          this.emit("tlsopen", void 0);
          try {
            for (; !a2; ) {
              const { done: e4, value: t4 } = await o2.read();
              a2 = e4, a2 || this.emit("tlsdata", t4);
            }
          } catch (e4) {
            this.emit("error", e4);
          }
        })();
      }
      on(e3, t3) {
        return "data" === e3 || "open" === e3 ? super.on("tls" + e3, t3) : super.on(e3, t3);
      }
      write(e3, t3) {
        if (e3.buffer)
          this.writer.write(e3.slice(0).buffer).then(t3);
        else if (e3.resize)
          this.writer.write(e3).then(t3);
        else {
          if ("string" != typeof e3)
            throw new Error("Invalid data type (not TypedArray, ArrayBuffer or String!!)");
          this.writer.write(e3).then(t3);
        }
      }
    }
    class Qt {
      _ws;
      _nextStreamID = 1;
      _bufferMax;
      streamMap = /* @__PURE__ */ new Map();
      constructor(e3, t3) {
        const s2 = () => {
          this._ws = new WebSocket(e3), this._ws.binaryType = "arraybuffer", this._ws.onmessage = (e4) => {
            const n2 = function(e5) {
              const t4 = new DataView(e5.buffer, e5.byteOffset), s3 = t4.getUint8(0), n3 = t4.getUint32(1, true);
              switch (s3) {
                case 1:
                  return { packetType: s3, streamID: n3, streamType: t4.getUint8(5), port: t4.getUint16(6, true), hostname: jt.decode(e5.subarray(8, e5.length)) };
                case 2:
                  return { packetType: s3, streamID: n3, payload: e5.subarray(5, e5.length) };
                case 3:
                  return { packetType: s3, streamID: n3, remainingBuffer: t4.getUint32(5, true) };
                case 4:
                  return { packetType: s3, streamID: n3, reason: t4.getUint8(5) };
                case 5:
                  const i2 = {};
                  i2.version_major = t4.getUint8(5), i2.version_minor = t4.getUint8(6);
                  let r2 = 7;
                  for (; r2 < e5.length; ) {
                    const s4 = t4.getUint8(r2), n4 = t4.getUint32(r2 + 1, true), o2 = e5.subarray(r2 + 5, r2 + 5 + n4);
                    i2[s4] = o2, r2 += 5 + n4;
                  }
                  return { packetType: s3, streamID: n3, infoObj: i2 };
              }
            }(new Uint8Array(e4.data));
            switch (n2.packetType) {
              case 2:
                this.streamMap.get(n2.streamID).dataCallBack(n2.payload.slice(0));
                break;
              case 3:
                if (0 === n2.streamID)
                  return this._bufferMax = n2.remainingBuffer, void (this._ws.onclose = () => {
                    setTimeout(s2(), 1e3);
                  });
                this.streamMap.get(n2.streamID).buffer = n2.remainingBuffer, this._continue();
                break;
              case 4:
                0 !== n2.streamID && this.streamMap.get(n2.streamID).closeCallBack(n2.reason);
                break;
              case 5:
                t3 && this._ws.send(Xt({ packetType: 5, streamID: 0, puterAuth: t3 }));
            }
          };
        };
        s2();
      }
      _continue(e3) {
        const t3 = this.streamMap.get(e3).queue;
        for (let s2 = 0; s2 < t3.length; s2++)
          this.write(e3, t3.shift());
      }
      register(e3, t3, s2) {
        const n2 = this._nextStreamID++;
        return this.streamMap.set(n2, { queue: [], streamID: n2, buffer: this._bufferMax, dataCallBack: s2.dataCallBack, closeCallBack: s2.closeCallBack }), this._ws.send(Xt({ packetType: 1, streamType: 1, streamID: n2, hostname: e3, port: t3 })), n2;
      }
      write(e3, t3) {
        const s2 = this.streamMap.get(e3);
        s2.buffer > 0 ? (s2.buffer--, this._ws.send(Xt({ packetType: 2, streamID: e3, payload: t3 }))) : s2.queue.push(t3);
      }
      close(e3) {
        this._ws.send(Xt({ packetType: 4, streamID: e3, reason: 2 }));
      }
    }
    class Zt extends pt {
      constructor({ options: e3, callback: t3 }) {
        super(["data", "end", "error"]), this.options = e3, this.callback = t3, this.buffer = [], this.onData_ = null;
      }
      set onData(e3) {
        this.onData_ = e3, this.buffer.length && (this.buffer.forEach((e4) => this.onData_(e4)), this.buffer = []);
      }
      write(e3) {
        this.onData_ ? this.onData_(e3) : this.buffer.push(e3);
      }
      end() {
        this.emit("end");
      }
    }
    const Jt = ({ Socket: e3, DEFAULT_PORT: t3 }) => {
      const s2 = { request: (s3, n2) => {
        var _a3;
        const i2 = new TextEncoder(), r2 = new TextDecoder();
        let o2;
        const a2 = new Zt(["data", "end", "error"]), c2 = new pt(["data", "end", "error"]);
        c2.headers = {}, c2.statusCode = null, c2.statusMessage = "";
        let l2 = "", h2 = 0;
        const u2 = { data: (e4) => {
          const t4 = parseInt(c2.headers["content-length"], 10);
          if (l2) {
            const t5 = i2.encode(l2);
            e4 = new Uint8Array([...t5, ...e4]), l2 = "";
          }
          h2 += e4.length, c2.emit("data", r2.decode(e4)), h2 >= t4 && o2.close();
        } }, d2 = { data: (e4) => {
          throw new Error("Chunked transfer encoding not implemented");
        } }, p2 = { data: (e4) => {
          if (l2) {
            const t4 = i2.encode(l2);
            e4 = new Uint8Array([...t4, ...e4]), l2 = "";
          }
          c2.emit("data", r2.decode(e4));
        } };
        let f2 = null, g2 = false;
        const m2 = { data: (e4) => {
          e4 = r2.decode(e4), l2 += e4;
          const t4 = l2.indexOf("\r\n\r\n");
          if (-1 === t4)
            return;
          const s4 = l2.substring(0, t4).split("\r\n");
          l2 = l2.substring(t4 + 4);
          const [i3, o3, ...a3] = s4[0].split(" ");
          c2.statusCode = parseInt(o3, 10), c2.statusMessage = a3.join(" ");
          for (let e5 = 1; e5 < s4.length; e5++) {
            const [t5, ...n3] = s4[e5].split(":");
            t5 && (c2.headers[t5.toLowerCase().trim()] = n3.join(":").trim());
          }
          if (g2)
            if ("chunked" === c2.headers["transfer-encoding"])
              f2 = d2;
            else {
              if (c2.headers["transfer-encoding"])
                throw new Error("Unsupported transfer encoding");
              if (!c2.headers["content-length"])
                throw new Error("No content length or transfer encoding");
              f2 = u2;
            }
          else
            f2 = p2;
          b2 = y2, n2(c2);
        } }, y2 = { data: (e4) => {
          f2.data(e4);
        } };
        let b2 = m2;
        const w2 = s3.method || "GET", v2 = s3.path || "/", _2 = s3.headers || {};
        _2.Host = s3.hostname, _2.Connection ? "close" !== _2.Connection && (g2 = true) : _2.Connection = "close";
        let A2 = `${w2} ${v2} HTTP/1.1\r
`;
        for (const [e4, t4] of Object.entries(_2))
          A2 += `${e4}: ${t4}\r
`;
        let k2 = [];
        s3.data && k2.push(s3.data), o2 = new e3(s3.hostname, (_a3 = s3.port) != null ? _a3 : t3);
        const I2 = new $e.libs.promise.TeePromise(), T2 = new $e.libs.promise.TeePromise();
        (async () => {
          await I2, a2.onData = (e4) => {
            "string" == typeof e4 && (e4 = i2.encode(e4)), k2.push(e4);
          }, await T2, k2.length && (A2 += `Content-Length: ${k2.reduce((e4, t4) => e4 + t4.length, 0)}\r
`), o2.write(i2.encode(A2)), o2.write(i2.encode("\r\n")), k2.forEach((e4) => o2.write(e4));
        })(), a2.on("end", () => {
          T2.resolve();
        }), o2.on("data", (e4) => {
          console.log("data event", e4), b2.data(e4);
        }), o2.on("open", () => {
          I2.resolve();
        }), o2.on("error", (e4) => {
          a2.emit("error", e4);
        });
        let x2 = false;
        return o2.on("close", () => {
          if (x2)
            console.error("close event after closed");
          else {
            if (x2 = true, l2) {
              console.log("close with buffer", l2);
              const e4 = i2.encode(l2);
              l2 = "", b2.data(e4);
            }
            c2.emit("end");
          }
        }), a2;
      } };
      return s2;
    };
    class $t {
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async exec(...e3) {
        const t3 = puter.fs.socket, s2 = new $e.libs.promise.TeePromise(), n2 = new $e.libs.promise.TeePromise(), i2 = async (e4) => {
          const r3 = await s2;
          e4.id === r3 && (n2.resolve(e4), t3.off("submission.done", i2));
        };
        t3.on("submission.done", i2);
        const { token: r2 } = await c(["runtime", "code", "stdin"], "puter-exec", void 0, "exec", { transform: async (e4) => (e4.toString = () => {
          var _a3;
          return (_a3 = e4.message) == null ? void 0 : _a3.content;
        }, e4.valueOf = () => {
          var _a3;
          return (_a3 = e4.message) == null ? void 0 : _a3.content;
        }, e4) }).call(this, ...e3);
        return s2.resolve(r2), await n2;
      }
    }
    const es = class {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin, this.appID = e3.appID;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      convert = async (...e3) => {
        let t3 = {};
        const s2 = {};
        if ("object" == typeof e3[0] && null !== e3[0])
          Object.assign(s2, e3.shift());
        else {
          if (e3.length < 2)
            throw new Error("usage: convert({ source, dest, from, to }) or convert(source, dest)");
          s2.source = e3.shift();
          const t4 = e3.shift();
          if (!t4.includes("."))
            throw new Error("cannot infer type for: " + e3[1]);
          s2.to = ((e4) => e4.slice(e4.lastIndexOf(".") + 1))(t4), s2.dest = t4;
        }
        e3.length && (t3.success = e3.shift()), e3.length && (t3.error = e3.shift());
        try {
          const e4 = await fetch(`${this.APIOrigin}/drivers/call`, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.authToken}` }, body: JSON.stringify({ interface: "convert-files", method: "convert", args: s2 }) });
          if (!e4.ok) {
            const t4 = await e4.json();
            throw new Error(t4.message || "Conversion failed");
          }
          const n2 = await e4.blob();
          return t3.success && "function" == typeof t3.success && t3.success(n2), n2;
        } catch (e4) {
          throw t3.error && "function" == typeof t3.error && t3.error(e4), e4;
        }
      };
    };
    class ts extends Error {
      constructor(e3) {
        super(e3), this.name = "RequestError";
      }
    }
    class ss {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async req_(e3, t3, s2) {
        const n2 = await fetch(this.APIOrigin + t3, { method: e3, headers: { Authorization: `Bearer ${this.authToken}`, ...s2 ? { "Content-Type": "application/json" } : {} }, ...s2 ? { body: JSON.stringify(s2) } : {} });
        if (!n2.ok) {
          const e4 = await n2.json(), t4 = new ts(e4.message);
          throw t4.response = e4, t4;
        }
        return await n2.json();
      }
      async create(e3, t3) {
        return "string" == typeof e3 && (e3 = { text: e3 }), await this.req_("POST", "/threads/create", { ...e3, ...t3 ? { parent: t3 } : {} });
      }
      async edit(e3, t3 = {}) {
        "string" == typeof t3 && (t3 = { text: t3 }), await this.req_("PUT", "/threads/edit/" + encodeURIComponent(e3), { ...t3 });
      }
      async delete(e3) {
        await this.req_("DELETE", "/threads/" + encodeURIComponent(e3));
      }
      async list(e3, t3, s2) {
        return await this.req_("POST", "/threads/list/" + encodeURIComponent(e3) + "/" + t3, s2 != null ? s2 : {});
      }
      async subscribe(e3, t3) {
        puter.fs.socket.emit("thread.sub-request", { uid: e3 });
        const s2 = ["post", "edit", "delete", "child-edit", "child-delete"];
        for (const n2 of s2)
          puter.fs.socket.on(`thread.${n2}`, (s3) => {
            s3.subscription === e3 && t3(n2, s3);
          });
      }
    }
    class ns {
      constructor(e3) {
        this.authToken = e3.authToken, this.APIOrigin = e3.APIOrigin;
      }
      setAuthToken(e3) {
        this.authToken = e3;
      }
      setAPIOrigin(e3) {
        this.APIOrigin = e3;
      }
      async req_(e3, t3) {
        const s2 = await fetch(this.APIOrigin + e3, { method: t3 ? "POST" : "GET", headers: { Authorization: `Bearer ${this.authToken}`, "Content-Type": "application/json" }, ...t3 ? { body: JSON.stringify(t3) } : {} });
        return await s2.json();
      }
      async grantUser(e3, t3) {
        return await this.req_("/auth/grant-user-user", { target_username: e3, permission: t3 });
      }
      async grantGroup(e3, t3) {
        return await this.req_("/auth/grant-user-group", { group_uid: e3, permission: t3 });
      }
      async grantApp(e3, t3) {
        return await this.req_("/auth/grant-user-app", { app_uid: e3, permission: t3 });
      }
      async grantAppAnyUser(e3, t3) {
        return await this.req_("/auth/grant-dev-app", { app_uid: e3, permission: t3 });
      }
      async grantOrigin(e3, t3) {
        return await this.req_("/auth/grant-user-app", { origin: e3, permission: t3 });
      }
      async revokeUser(e3, t3) {
        return await this.req_("/auth/revoke-user-user", { target_username: e3, permission: t3 });
      }
      async revokeGroup(e3, t3) {
        return await this.req_("/auth/revoke-user-group", { group_uid: e3, permission: t3 });
      }
      async revokeApp(e3, t3) {
        return await this.req_("/auth/revoke-user-app", { app_uid: e3, permission: t3 });
      }
      async revokeAppAnyUser(e3, t3) {
        return await this.req_("/auth/revoke-dev-app", { app_uid: e3, permission: t3 });
      }
      async revokeOrigin(e3, t3) {
        return await this.req_("/auth/revoke-user-app", { origin: e3, permission: t3 });
      }
      async createGroup(e3 = {}, t3 = {}) {
        return await this.req_("/group/create", { metadata: e3, extra: t3 });
      }
      async addUsersToGroup(e3, t3) {
        return await this.req_("/group/add-users", { uid: e3, users: t3 != null ? t3 : [] });
      }
      async removeUsersFromGroup(e3, t3) {
        return await this.req_("/group/remove-users", { uid: e3, users: t3 != null ? t3 : [] });
      }
      async listGroups() {
        return await this.req_("/group/list");
      }
    }
    window.puter = function() {
      const e3 = new class {
        env;
        defaultAPIOrigin = "https://api.puter.com";
        defaultGUIOrigin = "https://puter.com";
        onAuth;
        puterAuthState = { isPromptOpen: false, authGranted: null, resolver: null };
        appInstanceID;
        parentInstanceID;
        static FSItem = ht;
        eventHandlers = {};
        debugMode = false;
        initSubmodules = function() {
          this.util = new Tt(), this.registerModule("auth", vt), this.registerModule("os", p), this.registerModule("fs", ot), this.registerModule("ui", gt, { appInstanceID: this.appInstanceID, parentInstanceID: this.parentInstanceID }), this.registerModule("hosting", at), this.registerModule("email", ct), this.registerModule("apps", lt), this.registerModule("ai", wt), this.registerModule("kv", bt), this.registerModule("threads", ss), this.registerModule("perms", ns), this.registerModule("drivers", St), this.registerModule("debug", Ft), this.registerModule("exec", $t), this.registerModule("convert", es), this.path = Fe;
        };
        constructor(e4) {
          e4 = e4 != null ? e4 : {}, this.modules_ = [];
          const t3 = new $e.libs.context.Context().follow(this, ["env", "util", "authToken", "APIOrigin", "appID"]);
          t3.puter = this, this.services = new $e.system.ServiceManager({ context: t3 }), this.context = t3, t3.services = this.services;
          let s2 = new URLSearchParams(window.location.search);
          s2.has("puter.app_instance_id") ? this.env = "app" : true === window.puter_gui_enabled ? this.env = "gui" : this.env = "web", "gui" !== this.env && location.hostname.replace(/\.$/, "") === new URL("https://puter.com").hostname && (this.env = "gui"), s2.has("puter.args") ? this.args = JSON.parse(decodeURIComponent(s2.get("puter.args"))) : this.args = {}, s2.has("puter.app_instance_id") && (this.appInstanceID = decodeURIComponent(s2.get("puter.app_instance_id"))), s2.has("puter.parent_instance_id") && (this.parentInstanceID = decodeURIComponent(s2.get("puter.parent_instance_id"))), s2.has("puter.app.id") && (this.appID = decodeURIComponent(s2.get("puter.app.id"))), this.appID && (this.appDataPath = `~/AppData/${this.appID}`), this.APIOrigin = this.defaultAPIOrigin, s2.has("puter.api_origin") && "app" === this.env ? this.APIOrigin = decodeURIComponent(s2.get("puter.api_origin")) : s2.has("puter.domain") && "app" === this.env && (this.APIOrigin = "https://api." + s2.get("puter.domain"));
          let n2 = new $e.libs.log.ConsoleLogger();
          n2 = new $e.libs.log.CategorizedToggleLogger({ delegate: n2 });
          const i2 = n2;
          if (this.log = new $e.libs.log.LoggerFacade({ impl: n2, cat: i2 }), this.services.register("no-puter-yet", qt), this.services.register("filesystem", Lt), this.services.register("api-access", Ut), this.services.register("xd-incoming", Nt), "app" !== this.env && this.services.register("fs-relay", Ct), (async () => {
            await this.services.wait_for_init(["api-access"]);
            const e5 = this.services.get("api-access");
            e5.auth_token = this.authToken, e5.api_origin = this.APIOrigin, [["authToken", "auth_token"], ["APIOrigin", "api_origin"]].forEach(([t4, s3]) => {
              Object.defineProperty(this, t4, { get: () => e5[s3], set: (t5) => (e5[s3] = t5, true) });
            });
          })(), "gui" === this.env)
            this.authToken = window.auth_token, this.initSubmodules();
          else if ("app" === this.env) {
            this.authToken = decodeURIComponent(s2.get("puter.auth.token")), this.initSubmodules();
            try {
              localStorage.getItem("puter.auth.token") && this.setAuthToken(localStorage.getItem("puter.auth.token")), localStorage.getItem("puter.app.id") && this.setAppID(localStorage.getItem("puter.app.id"));
            } catch (e5) {
              console.error("Error accessing localStorage:", e5);
            }
          } else if ("web" === this.env) {
            this.initSubmodules();
            try {
              localStorage.getItem("puter.auth.token") && this.setAuthToken(localStorage.getItem("puter.auth.token")), localStorage.getItem("puter.app.id") && this.setAppID(localStorage.getItem("puter.app.id"));
            } catch (e5) {
              console.error("Error accessing localStorage:", e5);
            }
          }
          (async () => {
            var _a3, _b3;
            await this.services.wait_for_init(["api-access"]);
            const e5 = await this.auth.whoami();
            n2 = new $e.libs.log.PrefixLogger({ delegate: n2, prefix: "[" + ((_b3 = (_a3 = e5 == null ? void 0 : e5.app_name) != null ? _a3 : this.appInstanceID) != null ? _b3 : "HOST") + "] " }), this.log.impl = n2;
          })(), this.lock_rao_ = new $e.libs.promise.Lock(), this.p_can_request_rao_ = new $e.libs.promise.TeePromise(), this.rao_requested_ = false, (async () => {
            await this.services.wait_for_init(["api-access"]), this.p_can_request_rao_.resolve();
          })(), (async () => {
            const { token: e5, server: t4 } = await (await fetch(this.APIOrigin + "/wisp/relay-token/create", { method: "POST", headers: { Authorization: `Bearer ${this.authToken}`, "Content-Type": "application/json" }, body: JSON.stringify({}) })).json();
            Kt.handler = new Qt(t4, e5), this.net = { generateWispV1URL: async () => {
              const { token: e6, server: t5 } = await (await fetch(this.APIOrigin + "/wisp/relay-token/create", { method: "POST", headers: { Authorization: `Bearer ${this.authToken}`, "Content-Type": "application/json" }, body: JSON.stringify({}) })).json();
              return `${t5}/${e6}/`;
            }, Socket: Yt, tls: { TLSSocket: Ht } }, this.http = Jt({ Socket: this.net.Socket, DEFAULT_PORT: 80 }), this.https = Jt({ Socket: this.net.tls.TLSSocket, DEFAULT_PORT: 443 });
          })();
        }
        async request_rao_() {
          if (await this.p_can_request_rao_, "gui" === this.env)
            return;
          if (await this.lock_rao_.acquire(), this.rao_requested_)
            return void this.lock_rao_.release();
          let e4 = false;
          try {
            const e5 = await fetch(this.APIOrigin + "/rao", { method: "POST", headers: { Authorization: `Bearer ${this.authToken}` } });
            return await e5.json();
          } catch (t3) {
            e4 = true, console.error(t3);
          } finally {
            this.lock_rao_.release();
          }
          e4 || (this.rao_requested_ = true);
        }
        registerModule(e4, t3, s2 = {}) {
          const n2 = new t3(this.context, s2);
          this.modules_.push(e4), this[e4] = n2, n2._init && n2._init({ puter: this });
        }
        updateSubmodules() {
          var _a3, _b3, _c2, _d2;
          for (const e4 of this.modules_)
            this[e4] && ((_b3 = (_a3 = this[e4]) == null ? void 0 : _a3.setAuthToken) == null ? void 0 : _b3.call(_a3, this.authToken), (_d2 = (_c2 = this[e4]) == null ? void 0 : _c2.setAPIOrigin) == null ? void 0 : _d2.call(_c2, this.APIOrigin));
        }
        setAppID = function(e4) {
          try {
            localStorage.setItem("puter.app.id", e4);
          } catch (e5) {
            console.error("Error accessing localStorage:", e5);
          }
          this.appID = e4;
        };
        setAuthToken = function(e4) {
          if (this.authToken = e4, "web" === this.env || "app" === this.env)
            try {
              localStorage.setItem("puter.auth.token", e4);
            } catch (e5) {
              console.error("Error accessing localStorage:", e5);
            }
          this.updateSubmodules(), this.request_rao_();
        };
        setAPIOrigin = function(e4) {
          this.APIOrigin = e4, this.updateSubmodules();
        };
        resetAuthToken = function() {
          if (this.authToken = null, "web" === this.env || "app" === this.env)
            try {
              localStorage.removeItem("puter.auth.token");
            } catch (e4) {
              console.error("Error accessing localStorage:", e4);
            }
          this.updateSubmodules();
        };
        exit = function(e4 = 0) {
          e4 && "number" != typeof e4 && (console.warn("puter.exit() requires status code to be a number. Treating it as 1"), e4 = 1), window.parent.postMessage({ msg: "exit", appInstanceID: this.appInstanceID, statusCode: e4 }, "*");
        };
        randName = function(e4 = "-") {
          const t3 = ["helpful", "sensible", "loyal", "honest", "clever", "capable", "calm", "smart", "genius", "bright", "charming", "creative", "diligent", "elegant", "fancy", "colorful", "avid", "active", "gentle", "happy", "intelligent", "jolly", "kind", "lively", "merry", "nice", "optimistic", "polite", "quiet", "relaxed", "silly", "victorious", "witty", "young", "zealous", "strong", "brave", "agile", "bold"], s2 = ["street", "roof", "floor", "tv", "idea", "morning", "game", "wheel", "shoe", "bag", "clock", "pencil", "pen", "magnet", "chair", "table", "house", "dog", "room", "book", "car", "cat", "tree", "flower", "bird", "fish", "sun", "moon", "star", "cloud", "rain", "snow", "wind", "mountain", "river", "lake", "sea", "ocean", "island", "bridge", "road", "train", "plane", "ship", "bicycle", "horse", "elephant", "lion", "tiger", "bear", "zebra", "giraffe", "monkey", "snake", "rabbit", "duck", "goose", "penguin", "frog", "crab", "shrimp", "whale", "octopus", "spider", "ant", "bee", "butterfly", "dragonfly", "ladybug", "snail", "camel", "kangaroo", "koala", "panda", "piglet", "sheep", "wolf", "fox", "deer", "mouse", "seal", "chicken", "cow", "dinosaur", "puppy", "kitten", "circle", "square", "garden", "otter", "bunny", "meerkat", "harp"];
          return t3[Math.floor(Math.random() * t3.length)] + e4 + s2[Math.floor(Math.random() * s2.length)] + e4 + Math.floor(1e4 * Math.random());
        };
        getUser = function(...e4) {
          let t3;
          return t3 = "object" == typeof e4[0] && null !== e4[0] ? e4[0] : { success: e4[0], error: e4[1] }, new Promise((e5, s2) => {
            const i2 = n("/whoami", this.APIOrigin, this.authToken, "get");
            r(i2, t3.success, t3.error, e5, s2), i2.send();
          });
        };
        print = function(...e4) {
          for (let t3 of e4)
            document.body.innerHTML += t3;
        };
      }();
      return e3;
    }(), window.addEventListener("message", async (e3) => {
      e3.origin === puter.defaultGUIOrigin && (e3.data.msg && "requestOrigin" === e3.data.msg ? e3.source.postMessage({ msg: "originResponse" }, "*") : "puter.token" === e3.data.msg && (puter.setAuthToken(e3.data.token), puter.setAppID(e3.data.app_uid), puter.puterAuthState.authGranted = true, puter.onAuth && "function" == typeof puter.onAuth && puter.getUser().then((e4) => {
        puter.onAuth(e4);
      }), puter.puterAuthState.isPromptOpen = false, puter.puterAuthState.resolver && (puter.puterAuthState.authGranted ? puter.puterAuthState.resolver.resolve() : puter.puterAuthState.resolver.reject(), puter.puterAuthState.resolver = null)));
    });
  })();
})();
